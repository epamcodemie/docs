<article class="doc">
 <h1 class="page">
  What’s New in Mule 4
 </h1>
 <div id="preamble">
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     Mule 4’s simplified language and reduced management complexity enables you to speed up the on ramping process and deliver applications faster.
    </p>
   </div>
   <div class="paragraph">
    <p>
     If you are familiar with the concepts of the previous versions of the runtime, check the sections below to learn what’s changing in Mule Runtime v4.0.
    </p>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="simplified-event-and-message-model">
   <a class="anchor" href="#simplified-event-and-message-model">
   </a>
   Simplified Event and Message Model
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     Mule 4 includes a simplified Mule Event and Message model. In Mule 4, Flows are triggered by an Event. An Event has a Message and variables associated with it. A Message is composed of a payload and its attributes (metadata, such as file size). Variables hold arbitrary information, such as Messages, payload data, or attributes. This simplified message model makes it easier to work with data in a consistent way across connectors without information being overwritten.
    </p>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="dataweave-2-0-the-new-mule-expression-language">
   <a class="anchor" href="#dataweave-2-0-the-new-mule-expression-language">
   </a>
   DataWeave 2.0: The New Mule Expression Language
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     In Mule 3, users had to contend with learning both the Mule Expression Language (MEL) and DataWeave. MEL forced users to convert their payloads from binary data, such as XML or JSON documents, into Java objects, so they could write expressions which access that data, for example when routing to a specific location.
    </p>
   </div>
   <div class="paragraph">
    <p>
     In
     <strong>
      Mule 4
     </strong>
     , DataWeave is now the default expression language. Combined with the built-in streaming capabilities, this simplifies many common tasks:
    </p>
   </div>
   <div class="ulist">
    <ul>
     <li>
      <p>
       Events can be routed based on payload data, without first needing to convert them to Java objects.
      </p>
     </li>
     <li>
      <p>
       Binary data can easily be queried from an expression anywhere in your flow, for example, when logging.
      </p>
     </li>
     <li>
      <p>
       Larger than memory access to data happens transparently.
      </p>
     </li>
    </ul>
   </div>
   <div class="paragraph">
    <p>
     DataWeave 2.0 also features many improvements:
    </p>
   </div>
   <div class="ulist">
    <ul>
     <li>
      <p>
       Language simplifications. Everything is now a function.
      </p>
     </li>
     <li>
      <p>
       DataWeave scripts can now be packaged and reused, via the new imports and modules features.
      </p>
     </li>
     <li>
      <p>
       Support for multi-line comments.
      </p>
     </li>
     <li>
      <p>
       Support for calling static Java methods directly from DataWeave.
      </p>
     </li>
    </ul>
   </div>
   <div class="paragraph">
    <p>
     For details, see the links to
     <a href="#see_also">
      DataWeave documentation
     </a>
     .
    </p>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="streaming-management">
   <a class="anchor" href="#streaming-management">
   </a>
   Streaming Management
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     Mule 4 automatically handles data streams for users. This greatly simplifies working with data in the runtime because:
    </p>
   </div>
   <div class="ulist">
    <ul>
     <li>
      <p>
       Data can be read multiple times or accessed randomly using the DataWeave expression language without side effects.
      </p>
     </li>
     <li>
      <p>
       Data can be sent to multiple places, without the user caching that data in memory first.
      </p>
     </li>
     <li>
      <p>
       Users can transparently access larger than memory data.
      </p>
     </li>
     <li>
      <p>
       Users can customize whether data is stored on disk using streaming strategies.
      </p>
     </li>
    </ul>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="non-blocking-self-tuning-runtime">
   <a class="anchor" href="#non-blocking-self-tuning-runtime">
   </a>
   Non-Blocking, Self-Tuning Runtime
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     Mule 4 includes a new execution engine that is based on a non-blocking runtime. This is a task-oriented execution model allowing you to take advantage of non-blocking IO calls and avoid performance problems due to incorrect processing strategy configurations.
    </p>
   </div>
   <div class="paragraph">
    <p>
     As a result of this new engine, you no longer have to configure exchange patterns. Instead, flows always function synchronously. If you wish to achieve asynchronous type patterns such as fire and forget, you can use the
     <code>
      &lt;async&gt;
     </code>
     processor.
    </p>
   </div>
   <div class="paragraph">
    <p>
     Each Mule event processor can now inform the runtime if it is a CPU intensive, CPU light, or IO intensive operation. This helps the runtime to self-tune for different workloads dynamically, removing the need for you to manage thread pools manually. As a result, Mule 4 removes complex tuning requirements to achieve optimum performance.
    </p>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="enrich-events-directly-from-connectorsmodules">
   <a class="anchor" href="#enrich-events-directly-from-connectorsmodules">
   </a>
   Enrich Events Directly from Connectors/Modules
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     For any given module operation, it is now possible to define a target (or target variable), which saves the result in a variable:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http:request target="myVar" config-ref="requestConfig" method="GET" url="http://mulesoft.com"/&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     This saves the Mule message in the
     <code>
      myVar
     </code>
     variable to be accessed later. This reduces flow complexity by removing the need for an enricher.
    </p>
   </div>
   <div class="paragraph">
    <p>
     You can also control what is stored in the variable using the targetValue attribute. For example, if you wanted to only store the response code from an HTTP request, you could do the following:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;http:request target="myVar" targetValue="#[attributes.statusCode]" .../&gt;</code></pre>
    </div>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="simplified-connectors-and-modules-experience">
   <a class="anchor" href="#simplified-connectors-and-modules-experience">
   </a>
   Simplified Connectors and Modules Experience
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     Mule 4 introduces more consistency around modules and connectors, creating one unified experience for how to interact with Mule components.
    </p>
   </div>
   <div class="paragraph">
    <p>
     Transports have been completely replaced by Mule Modules. Modules and connectors can be created and managed using the Mule SDK, which provides a single way to extend Mule.
    </p>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="simplified-error-handling-and-new-try-scope">
   <a class="anchor" href="#simplified-error-handling-and-new-try-scope">
   </a>
   Simplified Error Handling and New Try Scope
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     Mule 4 includes a simplified way to manage errors. Instead of dealing with Java exceptions directly, there is now an Error concept built directly into Mule. Furthermore, Mule Modules and Connectors declare what Errors may occur for any given operation. This makes it easy for you to discover possible errors at design time and catch them.
    </p>
   </div>
   <div class="paragraph">
    <p>
     Exception strategies are replaced by error handlers allowing you to catch errors based on both type and arbitrary expressions.
    </p>
   </div>
   <div class="paragraph">
    <p>
     You can configure your error handlers to catch errors so that the flow can keep processing, or they can be re-propagated.
    </p>
   </div>
   <div class="paragraph">
    <p>
     There is also a new Try Scope, which allows you to catch errors in the middle of a flow without having to create a new flow, specifically to catch that error.
    </p>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="batch-is-easier-to-use-and-is-now-a-scope">
   <a class="anchor" href="#batch-is-easier-to-use-and-is-now-a-scope">
   </a>
   Batch is easier to use and is now a scope
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     In Mule 3, batch jobs were top-level concerns, similar flows. But we’ve simplified this so it is now a scope that can live inside a flow–– making it easier to understand, invoke dynamically, and interact with other Mule components. There are also no longer a special set of variables (i.e. recordVars) for batch. You can now just use flow variables directly; this reduces the complexity and makes it easier to learn how to write batch jobs.
    </p>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="improved-upgradeability-with-classloader-isolation">
   <a class="anchor" href="#improved-upgradeability-with-classloader-isolation">
   </a>
   Improved Upgradeability with Classloader Isolation
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     Mule 4 loads each Module in its own classloader, isolating the modules from internal Mule code making runtime upgrades a lot simpler by protecting you from changes by the runtime or connectors:
    </p>
   </div>
   <div class="ulist">
    <ul>
     <li>
      <p>
       Connectors are now distributed outside the runtime, making it possible to:
      </p>
      <div class="ulist">
       <ul>
        <li>
         <p>
          Get connector enhancements and fixes without having to upgrade your runtime.
         </p>
        </li>
        <li>
         <p>
          Upgrade your runtime version without breaking compatibility with other modules.
         </p>
        </li>
       </ul>
      </div>
     </li>
     <li>
      <p>
       There is now a well-defined Mule API, so you can be sure you’re using supported APIs.
      </p>
     </li>
     <li>
      <p>
       There is classloader isolation between your application, the runtime, and connectors, so that any library changes that happen internally will not affect your app.
      </p>
     </li>
    </ul>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="improved-support-for-configuration">
   <a class="anchor" href="#improved-support-for-configuration">
   </a>
   Improved support for configuration
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     Mule 4 features an easier way to configure environment specific properties, which is Spring-optional. With it, you can now define application-specific properties in a YAML file inside your application. These will be the default properties for your application and you can override them using system properties. In the future, we’ll also be using this metadata to provide an improved configuration management UI from runtime manager.
    </p>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="connectors-and-modules-updates">
   <a class="anchor" href="#connectors-and-modules-updates">
   </a>
   Connectors and Modules Updates
  </h2>
  <div class="sectionbody">
   <div class="sect2">
    <h3 id="database-connector">
     <a class="anchor" href="#database-connector">
     </a>
     Database Connector
    </h3>
    <div class="paragraph">
     <p>
      The database connector has undergone minor updates:
     </p>
    </div>
    <div class="ulist">
     <ul>
      <li>
       <p>
        Bulk operations have been separated so that operations do not change behavior depending on the received payload
       </p>
      </li>
      <li>
       <p>
        There’s single experience for executing static and dynamic queries.
       </p>
      </li>
      <li>
       <p>
        DataWeave transformations can be embedded inside the insert/update operations so that you can construct the datasets you want to send to the DB without having a side effect on the message or using enrichers
       </p>
      </li>
      <li>
       <p>
        The connector will use Mule’s new streaming framework to handle large data sets.
       </p>
      </li>
     </ul>
    </div>
   </div>
   <div class="sect2">
    <h3 id="file-and-ftp-connectors">
     <a class="anchor" href="#file-and-ftp-connectors">
     </a>
     File and FTP Connectors
    </h3>
    <div class="paragraph">
     <p>
      The File and FTP connectors have been improved so that they are operation based and share the same set of operations. This enables many new capabilities:
     </p>
    </div>
    <div class="ulist">
     <ul>
      <li>
       <p>
        The ability to read files or fully list directories’ contents on demand, unlike the old transport (which only provided a polling inbound endpoint)
       </p>
      </li>
      <li>
       <p>
        Top level support for common file system operations such as copying, moving, renaming, deleting, creating directories, and more
       </p>
      </li>
      <li>
       <p>
        Support for locking files on the file system level
       </p>
      </li>
      <li>
       <p>
        Advanced file matching functionality
       </p>
      </li>
      <li>
       <p>
        Support for local files, FTP, SFTP and FTPS
       </p>
      </li>
     </ul>
    </div>
   </div>
   <div class="sect2">
    <h3 id="jms-connector">
     <a class="anchor" href="#jms-connector">
     </a>
     JMS Connector
    </h3>
    <div class="paragraph">
     <p>
      The JMS connector has been updated to utilize the new, simplified connector experience. In addition to the JMS listener and sender, you can also consume messages in the middle of a flow using the JMS consume operation.
     </p>
    </div>
   </div>
   <div class="sect2">
    <h3 id="scripting-module">
     <a class="anchor" href="#scripting-module">
     </a>
     Scripting Module
    </h3>
    <div class="paragraph">
     <p>
      The scripting module is now updated for Mule 4, enabling you to now embed your Groovy, Ruby, Python, or JavaScript scripts inside Mule flows. You can inject data from the Mule message into your code using the new parameters configuration attribute.
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;script:execute engine="groovy"&gt;
    &lt;script:code&gt;
         return "$payload $prop1 $prop2"
    &lt;/script:code&gt;
    &lt;script:parameters&gt;
         #[{prop1: "Received", prop2: "A-OK"}]
    &lt;/script:parameters&gt;
&lt;/script:execute&gt;</code></pre>
     </div>
    </div>
   </div>
   <div class="sect2">
    <h3 id="spring-module">
     <a class="anchor" href="#spring-module">
     </a>
     Spring module
    </h3>
    <div class="paragraph">
     <p>
      Mule 4 decouples the Mule internals from Spring, ensuring that users don’t need to know Spring to learn Mule and enables Spring users to select which version of spring they run. To use Spring beans, now you add the Spring module to your application, and simply import your Spring bean files.
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;spring:config name="springConfig" files="beans.xml"/&gt;</code></pre>
     </div>
    </div>
   </div>
   <div class="sect2">
    <h3 id="vm-connector">
     <a class="anchor" href="#vm-connector">
     </a>
     VM Connector
    </h3>
    <div class="paragraph">
     <p>
      The VM connector has been updated to utilize the new, simplified connector experience. In addition to the VM listener and sender, you can also consume messages in the middle of a flow using the VM consume operation
     </p>
    </div>
   </div>
   <div class="sect2">
    <h3 id="other-modules-and-connectors">
     <a class="anchor" href="#other-modules-and-connectors">
     </a>
     Other Modules and Connectors
    </h3>
    <div class="paragraph">
     <p>
      All other modules and connectors that have been updated have been updated to be consistent with the overall Mule 4 experience, but have otherwise gone through no functionality changes unless explicitly noted in their release notes.
     </p>
    </div>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="mule-sdk">
   <a class="anchor" href="#mule-sdk">
   </a>
   Mule SDK
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     The Mule SDK is a successor to the Anypoint Connector Devkit. It enables developers to easily extend Mule and create new Mule modules which can be shared in Exchange. Unlike Mule 3, where there were multiple ways to create extensions, the Mule 4 SDK provides a single way to extend Mule, assuring consistency and upgradeability of components. It was used to build all Mule 4 modules and connectors.
    </p>
   </div>
   <div class="paragraph">
    <p>
     While similar to DevKit in many respects, it features many improvements:
    </p>
   </div>
   <div class="ulist">
    <ul>
     <li>
      <p>
       The SDK does not generate code, which enables extensions to get new runtime features without having to be re-released
      </p>
     </li>
     <li>
      <p>
       Transactions support
      </p>
     </li>
     <li>
      <p>
       Request-Response event sources support
      </p>
     </li>
     <li>
      <p>
       Dynamic configurations
      </p>
     </li>
     <li>
      <p>
       Router support
      </p>
     </li>
     <li>
      <p>
       Non Blocking operations
      </p>
     </li>
     <li>
      <p>
       Classloading isolation
      </p>
     </li>
    </ul>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="see_also">
   <a class="anchor" href="#see_also">
   </a>
   See Also
  </h2>
  <div class="sectionbody">
   <div class="ulist">
    <ul>
     <li>
      <p>
       <a class="xref page" href="about-mule-event">
        Mule Events
       </a>
      </p>
     </li>
     <li>
      <p>
       <a class="xref page" href="dataweave">
        DataWeave Language
       </a>
      </p>
     </li>
     <li>
      <p>
       <a class="xref page" href="migration-dataweave">
        Migrating from DataWeave version 1 to 2
       </a>
      </p>
     </li>
     <li>
      <p>
       <a class="xref page" href="about-components">
        Core Components
       </a>
      </p>
     </li>
     <li>
      <p>
       <a class="xref page" href="try-scope-concept">
        Try Scope
       </a>
      </p>
     </li>
    </ul>
   </div>
  </div>
 </div>
</article>
