<article class="doc">
 <h1 class="page">
  Property placeholders
 </h1>
 <div id="preamble">
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     Camel has extensive support for property placeholders, which can be used
     <em>
      almost anywhere
     </em>
     in your Camel
     <a class="xref page" href="routes.html">
      routes
     </a>
     ,
     <a class="xref page" href="endpoint.html">
      endpoints
     </a>
     ,
     <a class="xref page" href="dsl.html">
      DSL
     </a>
     , and
     <a class="xref page" href="route-configuration.html">
      route configuration
     </a>
     ,
     <a class="xref page" href="bean-integration.html">
      bean integration
     </a>
     and elsewhere.
    </p>
   </div>
   <div class="paragraph">
    <p>
     Property placeholders are used to define a
     <em>
      placeholder
     </em>
     instead of the actual value. This is important as you would want to be able to make your applications external configurable, such as values for network addresses, port numbers, authentication credentials, login tokens, and configuration in general.
    </p>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="_properties_component">
   <a class="anchor" href="#_properties_component">
   </a>
   Properties component
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     Camel provides the
     <a class="xref page" href="../components/4.10.x/properties-component.html">
      Properties
     </a>
     out of the box from the core, which is responsible for handling and resolving the property placeholders.
    </p>
   </div>
   <div class="paragraph">
    <p>
     See the
     <a class="xref page" href="../components/4.10.x/properties-component.html">
      Properties
     </a>
     documentation for how to configure Camel to known from which location(a) to load properties.
    </p>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="_property_placeholder_syntax">
   <a class="anchor" href="#_property_placeholder_syntax">
   </a>
   Property placeholder syntax
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     The value of a Camel property can be obtained by specifying its key name within a property placeholder, using the following syntax:
     <code>
      {{key}}
     </code>
    </p>
   </div>
   <div class="paragraph">
    <p>
     For example:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">{{file.uri}}</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     where
     <code>
      file.uri
     </code>
     is the property key.
    </p>
   </div>
   <div class="paragraph">
    <p>
     Property placeholders can be used to specify parts, or all, of an endpoint’s URI by embedding one or more placeholders in the URI’s string definition.
    </p>
   </div>
   <div class="sect2">
    <h3 id="_using_property_placeholder_with_default_value">
     <a class="anchor" href="#_using_property_placeholder_with_default_value">
     </a>
     Using property placeholder with default value
    </h3>
    <div class="paragraph">
     <p>
      You can specify a default value to use if a property with the key does not exist, where the default value is the text after the colon:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">{{file.url:/some/path}}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      In this case the default value is
      <code>
       /some/path
      </code>
      .
     </p>
    </div>
   </div>
   <div class="sect2">
    <h3 id="_using_optional_property_placeholders">
     <a class="anchor" href="#_using_optional_property_placeholders">
     </a>
     Using optional property placeholders
    </h3>
    <div class="paragraph">
     <p>
      Camel’s elaborate property placeholder feature supports optional placeholders, which is defined with the
      <code>
       ?
      </code>
      (question mark) as prefix in the key name, as shown:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">{{?myBufferSize}}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      If a value for the key exists then the value is used, however if the key does not exist, then Camel understands this, such as when used in
      <a class="xref page" href="endpoint.html">
       Endpoints
      </a>
      :
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">file:foo?bufferSize={{?myBufferSize}}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      Then the
      <code>
       bufferSize
      </code>
      option will only be configured in the endpoint, if a placeholder exists. Otherwise the option will not be set on the endpoint, meaning the endpoint would be
      <em>
       restructued
      </em>
      as:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">file:foo</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      Then the option
      <code>
       bufferSize
      </code>
      is not in specified at all, and this would allow Camel to use the standard default value for
      <code>
       bufferSize
      </code>
      if any exists.
     </p>
    </div>
   </div>
   <div class="sect2">
    <h3 id="_reverse_a_boolean_value">
     <a class="anchor" href="#_reverse_a_boolean_value">
     </a>
     Reverse a boolean value
    </h3>
    <div class="paragraph">
     <p>
      If a property placeholder is a boolean value, then it is possible to negate (reverse) the value by using
      <code>
       !
      </code>
      as prefix in the key.
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">integration.ftpEnabled=true</code></pre>
     </div>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">from("ftp:....").autoStartup("{{integration.ftpEnabled}}")
    .to("kafka:cheese")

from("jms:....").autoStartup("{{!integration.ftpEnabled}}")
    .to("kafka:cheese")</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      In the example above then the FTP route or the JMS route should only be started. So if the FTP is enabled then JMS should be disable, and vise-versa. We can do this be negating the
      <code>
       autoStartup
      </code>
      in the JMS route, by using
      <code>
       !integration.ftpEnabled
      </code>
      as the key.
     </p>
    </div>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="_using_property_placeholders">
   <a class="anchor" href="#_using_property_placeholders">
   </a>
   Using property placeholders
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     When using property placeholders in the endpoint
     <a class="xref page" href="uris.html">
      URIs
     </a>
     you should use this with the syntax
     <code>
      {{key}}
     </code>
     as shown in this example:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">cool.end = mock:result
where = cheese</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     And in Java DSL:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">from("direct:start")
    .to("{{cool.end}}");</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     And in XML DSL:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;route&gt;
  &lt;from uri="direct:start"/&gt;
  &lt;to uri="{{cool.end}}"/&gt;
&lt;/route&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     A property placeholder may also just be a one part in the endpoint URI. A common use-case is to use a placeholder for an endpoint option such as the size of the write buffer in the file endpoint:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">buf = 8192</code></pre>
    </div>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">from("direct:start")
    .to("file:outbox?bufferSize={{buf}}");</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     And in XML DSL:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;route&gt;
  &lt;from uri="direct:start"/&gt;
  &lt;to uri="file:outbox?bufferSize={{buf}}"/&gt;
&lt;/route&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     However the placeholder can be anywhere, so it could also be the name of a mock endpoint
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">from("direct:start")
    .to("mock:{{where}}");</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     In the example above the mock endpoint, is already hardcoded to start with
     <code>
      mock:
     </code>
     , and the
     <code>
      where
     </code>
     placeholder has the value
     <code>
      cheese
     </code>
     so the resolved uri becomes
     <code>
      mock:cheese
     </code>
     .
    </p>
   </div>
   <div class="sect2">
    <h3 id="_property_placeholders_referring_to_other_properties_nested_placeholders">
     <a class="anchor" href="#_property_placeholders_referring_to_other_properties_nested_placeholders">
     </a>
     Property placeholders referring to other properties (nested placeholders)
    </h3>
    <div class="paragraph">
     <p>
      You can also have properties with refer to each other such as:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">cool.foo=result
cool.concat=mock:{{cool.foo}}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      Notice how
      <code>
       cool.concat
      </code>
      refer to another property.
     </p>
    </div>
    <div class="paragraph">
     <p>
      And the route in XML:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;route&gt;
  &lt;from uri="direct:start"/&gt;
  &lt;to uri="{{cool.concat}}"/&gt;
&lt;/route&gt;</code></pre>
     </div>
    </div>
    <div class="sect3">
     <h4 id="_turning_off_nested_placeholders">
      <a class="anchor" href="#_turning_off_nested_placeholders">
      </a>
      Turning off nested placeholders
     </h4>
     <div class="paragraph">
      <p>
       If the placeholder value contains data that interfere with the property placeholder syntax
       <code>
        {{
       </code>
       and
       <code>
        }}
       </code>
       (such as JSon data), you can be then explicit turn off nested placeholder by
       <code>
        ?nested=false
       </code>
       in the key name, such as shown:
      </p>
     </div>
     <div class="listingblock">
      <div class="content">
       <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;route&gt;
  &lt;from uri="direct:start"/&gt;
  &lt;to uri="elasticsearch:foo?query={{myQuery?nested=false}}"/&gt;
&lt;/route&gt;</code></pre>
      </div>
     </div>
     <div class="paragraph">
      <p>
       In the example above the placeholder
       <em>
        myQuery
       </em>
       placeholder value is as follows
      </p>
     </div>
     <div class="listingblock">
      <div class="content">
       <pre class="highlightjs highlight"><code class="language-json hljs" data-lang="json">{"query":{"match_all":{}}}</code></pre>
      </div>
     </div>
     <div class="paragraph">
      <p>
       Notice how the json query ends with
       <code>
        }}
       </code>
       which interfere with the Camel property placeholder syntax.
      </p>
     </div>
     <div class="paragraph">
      <p>
       Nested placeholders can also be turned off globally on the
       <a class="xref page" href="../components/4.10.x/properties-component.html">
        Properties
       </a>
       component, such as:
      </p>
     </div>
     <div class="listingblock">
      <div class="content">
       <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CamelContext context = ...
context.getPropertiesComponent().setNestedPlaceholder(false);</code></pre>
      </div>
     </div>
    </div>
   </div>
   <div class="sect2">
    <h3 id="_escape_a_property_placeholder">
     <a class="anchor" href="#_escape_a_property_placeholder">
     </a>
     Escape a property placeholder
    </h3>
    <div class="paragraph">
     <p>
      The property placeholder can be problematic if the double curly brackets are used by a third party library like for example a query in ElasticSearch of type
      <code>
       {"query":{"match_all":{}}}
      </code>
      .
     </p>
    </div>
    <div class="paragraph">
     <p>
      To work around that it is possible to escape the double curly brackets with a backslash character like for example
      <code>
       \{{ property-name \}}
      </code>
      . This way, it won’t be interpreted as a property placeholder to resolve and will be resolved as
      <code>
       {{ property-name }}
      </code>
      .
     </p>
    </div>
    <div class="paragraph">
     <p>
      If for some reason, the backslash character before the double curly brackets must not be interpreted as an escape character, it is possible to add another backslash in front of it to escape it, it will then be seen as a backslash.
     </p>
    </div>
   </div>
   <div class="sect2">
    <h3 id="_using_property_placeholders_multiple_times">
     <a class="anchor" href="#_using_property_placeholders_multiple_times">
     </a>
     Using property placeholders multiple times
    </h3>
    <div class="paragraph">
     <p>
      You can of course also use placeholders several times:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">cool.start=direct:start
cool.showid=true
cool.result=result</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      And in this route we use
      <code>
       cool.start
      </code>
      two times:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">from("{{cool.start}}")
    .to("log:{{cool.start}}?showBodyType=false&amp;showExchangeId={{cool.showid}}")
    .to("mock:{{cool.result}}");</code></pre>
     </div>
    </div>
   </div>
   <div class="sect2">
    <h3 id="_using_property_placeholders_with_producer_template">
     <a class="anchor" href="#_using_property_placeholders_with_producer_template">
     </a>
     Using property placeholders with producer template
    </h3>
    <div class="paragraph">
     <p>
      You can also your property placeholders when using
      <a class="xref page" href="producertemplate.html">
       ProducerTemplate
      </a>
      for example:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">template.sendBody("{{cool.start}}", "Hello World");</code></pre>
     </div>
    </div>
   </div>
   <div class="sect2">
    <h3 id="_using_property_placeholders_with_consumer_template">
     <a class="anchor" href="#_using_property_placeholders_with_consumer_template">
     </a>
     Using property placeholders with consumer template
    </h3>
    <div class="paragraph">
     <p>
      This can also be done when using
      <a class="xref page" href="consumertemplate.html">
       ConsumerTemplate
      </a>
      , such as:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Object body = template.receiveBody("{{cool.start}}");</code></pre>
     </div>
    </div>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="_resolving_property_placeholders_on_cloud">
   <a class="anchor" href="#_resolving_property_placeholders_on_cloud">
   </a>
   Resolving property placeholders on cloud
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     When you are running your Camel application on the cloud you may want to automatically scan any Configmap or Secret as it was an application properties. Given the following Secret:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre>apiVersion: v1
data:
  my-property: Q2FtZWwgNC44
kind: Secret
metadata:
  name: my-secret
type: Opaque</pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     You can mount it in your Pod container, for instance, under
     <code>
      /etc/camel/conf.d/_secrets/my-secret
     </code>
     . Now, just make your Camel application be aware where to scan your configuration via
     <code>
      camel.main.cloud-properties-location = /etc/camel/conf.d/_secrets/my-secret
     </code>
     application properties. It’s a comma separated value, so, you can add as many Secrets/Configmaps you need.
    </p>
   </div>
   <div class="paragraph">
    <p>
     At runtime, you will be able to read the configuration transparently as
     <code>
      <code>
       {{ my-property }}
      </code>
     </code>
     as you’re doing with the rest of properties.
    </p>
   </div>
   <div class="admonitionblock note">
    <div class="table-wrapper">
     <table>
      <tr>
       <td class="icon">
        <i class="fa icon-note" title="Note">
        </i>
       </td>
       <td class="content">
        the same configuration works with Configmap.
       </td>
      </tr>
     </table>
    </div>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="_resolving_property_placeholders_from_java_code">
   <a class="anchor" href="#_resolving_property_placeholders_from_java_code">
   </a>
   Resolving property placeholders from Java code
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     If you need to resolve property placeholder(s) from some Java code, then Camel has two APIs for this:
    </p>
   </div>
   <div class="ulist">
    <ul>
     <li>
      <p>
       You can use the method
       <code>
        resolveProperty
       </code>
       on the
       <code>
        PropertiesComponent
       </code>
       to resolve a single property from Java code.
      </p>
     </li>
     <li>
      <p>
       Use the method
       <code>
        resolvePropertyPlaceholders
       </code>
       on the
       <code>
        CamelContext
       </code>
       to resolve (one or more) property placeholder(s) in a String.
      </p>
     </li>
    </ul>
   </div>
   <div class="paragraph">
    <p>
     For example to resolve a placeholder with key foo, you can do:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Optional&lt;String&gt; prop = camelContext.getPropertiesComponent().resolveProperty("foo");
if (prop.isPresent()) {
    String value = prop.get();
    ....
}</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     This API is to lookup a single property and returns a
     <code>
      java.util.Optional
     </code>
     type.
    </p>
   </div>
   <div class="paragraph">
    <p>
     The
     <code>
      CamelContext
     </code>
     have another API which is capable of resolving multiple placeholders, and interpolate placeholders from an input String. Lets try with an example to explain this:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">String msg = camelContext.resolvePropertyPlaceholders("{{greeting}} Camel user, Camel is {{cool}} dont you think?");</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     The input string is a text statement which have two placeholders that will be resolved, for example:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">greeting = Hi
cool = awesome</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     Will be resolved to:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text">Hi Camel user, Camel is awesome dont you think?</code></pre>
    </div>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="_using_property_placeholders_for_any_kind_of_attribute_in_spring_xml_files">
   <a class="anchor" href="#_using_property_placeholders_for_any_kind_of_attribute_in_spring_xml_files">
   </a>
   Using property placeholders for any kind of attribute in Spring XML files
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     Previously it was only the
     <code>
      xs:string
     </code>
     type attributes in the XML DSL that support placeholders. For example often a timeout attribute would be a
     <code>
      xs:int
     </code>
     type and thus you cannot set a string value as the placeholder key. This is now possible using a special placeholder namespace.
    </p>
   </div>
   <div class="paragraph">
    <p>
     In the example below we use the
     <code>
      prop
     </code>
     prefix for the namespace
     <code>
      http://camel.apache.org/schema/placeholder
     </code>
     . Now we can use
     <code>
      prop:
     </code>
     as prefix to configure any kind of XML attributes in Spring XML files.
    </p>
   </div>
   <div class="paragraph">
    <p>
     In the example below we want to use a placeholder for the
     <code>
      stopOnException
     </code>
     option in the
     <a class="xref page" href="../components/4.10.x/eips/multicast-eip.html">
      Multicast
     </a>
     EIP. The
     <code>
      stopOnException
     </code>
     is a
     <code>
      xs:boolean
     </code>
     type, so we cannot configure this as:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;multicast stopOnException="{{stop}}"&gt;
   ...
&lt;/multicast&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     Instead, we must use the
     <code>
      prop:
     </code>
     namespace, so we must add this namespace in the top of the XML file in the
     <code>
      &lt;beans&gt;
     </code>
     tag.
    </p>
   </div>
   <div class="paragraph">
    <p>
     To configure the option we must then use the
     <code>
      prop:optionName
     </code>
     as shown below:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;multicast prop:stopOnException="stop"&gt;
  ...
&lt;/multicast&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     The complete example is below:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:prop="http://camel.apache.org/schema/placeholder"
       xsi:schemaLocation="
           http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
           http://camel.apache.org/schema/spring http://camel.apache.org/schema/spring/camel-spring.xsd"&gt;

    &lt;bean id="damn" class="java.lang.IllegalArgumentException"&gt;
        &lt;constructor-arg index="0" value="Damn"/&gt;
    &lt;/bean&gt;

    &lt;camelContext xmlns="http://camel.apache.org/schema/spring"&gt;
        &lt;propertyPlaceholder id="properties" location="classpath:myprop.properties"/&gt;
        &lt;route&gt;
            &lt;from uri="direct:start"/&gt;
            &lt;!-- use prop namespace, to define a property placeholder, which maps to option stopOnException={{stop}} --&gt;
            &lt;multicast prop:stopOnException="stop"&gt;
                &lt;to uri="mock:a"/&gt;
                &lt;throwException ref="damn"/&gt;
                &lt;to uri="mock:b"/&gt;
            &lt;/multicast&gt;
        &lt;/route&gt;
    &lt;/camelContext&gt;
&lt;/beans&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     In our properties file we have the value defined as:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">stop = true</code></pre>
    </div>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="_bridging_camel_property_placeholders_with_spring_xml_files">
   <a class="anchor" href="#_bridging_camel_property_placeholders_with_spring_xml_files">
   </a>
   Bridging Camel property placeholders with Spring XML files
  </h2>
  <div class="sectionbody">
   <div class="admonitionblock note">
    <div class="table-wrapper">
     <table>
      <tr>
       <td class="icon">
        <i class="fa icon-note" title="Note">
        </i>
       </td>
       <td class="content">
        If you are using Spring Boot then this does not apply. This is only for legacy Camel and Spring applications which are using Spring XML files.
       </td>
      </tr>
     </table>
    </div>
   </div>
   <div class="paragraph">
    <p>
     The Spring Framework does not allow third-party frameworks such as Apache Camel to seamless hook into the Spring property placeholder mechanism. However, you can bridge Spring and Camel by declaring a Spring bean with the type
     <code>
      org.apache.camel.spring.spi.BridgePropertyPlaceholderConfigurer
     </code>
     , which is a Spring
     <code>
      org.springframework.beans.factory.config.PropertyPlaceholderConfigurer
     </code>
     type.
    </p>
   </div>
   <div class="paragraph">
    <p>
     To bridge Spring and Camel you must define a single bean as shown below:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- bridge spring property placeholder with Camel --&gt;
&lt;!-- you must NOT use the &lt;context:property-placeholder at the same time, only this bridge bean --&gt;
&lt;bean id="bridgePropertyPlaceholder" class="org.apache.camel.spring.spi.BridgePropertyPlaceholderConfigurer"&gt;
  &lt;property name="location" value="classpath:org/apache/camel/component/properties/cheese.properties"/&gt;
&lt;/bean&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     You
     <strong>
      must not
     </strong>
     use the spring
     <code>
      &lt;context:property-placeholder&gt;
     </code>
     namespace at the same time; this is not possible.
    </p>
   </div>
   <div class="paragraph">
    <p>
     After declaring this bean, you can define property placeholders using both the Spring style, and the Camel style within the
     <code>
      &lt;camelContext&gt;
     </code>
     tag as shown below:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;!-- a bean that uses Spring property placeholder --&gt;
&lt;!-- the ${hi} is a spring property placeholder --&gt;
&lt;bean id="hello" class="org.apache.camel.component.properties.HelloBean"&gt;
  &lt;property name="greeting" value="${hi}"/&gt;
&lt;/bean&gt;

&lt;camelContext xmlns="http://camel.apache.org/schema/spring"&gt;
  &lt;!-- in this route we use Camels property placeholder {{ }} style --&gt;
  &lt;route&gt;
    &lt;from uri="direct:{{cool.bar}}"/&gt;
    &lt;bean ref="hello"/&gt;
    &lt;to uri="{{cool.end}}"/&gt;
  &lt;/route&gt;
&lt;/camelContext&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     Notice how the hello bean is using pure Spring property placeholders using the
     <code>
      ${}
     </code>
     notation. And in the Camel routes we use the Camel placeholder notation with
     <code>
      {{key}}
     </code>
     .
    </p>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="_using_property_placeholder_functions">
   <a class="anchor" href="#_using_property_placeholder_functions">
   </a>
   Using property placeholder functions
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     The
     <a class="xref page" href="../components/4.10.x/properties-component.html">
      Properties
     </a>
     component includes the following functions out of the box:
    </p>
   </div>
   <div class="ulist">
    <ul>
     <li>
      <p>
       <code>
        env
       </code>
       - A function to lookup the property from OS environment variables
      </p>
     </li>
     <li>
      <p>
       <code>
        sys
       </code>
       - A function to lookup the property from Java JVM system properties
      </p>
     </li>
     <li>
      <p>
       <code>
        bean
       </code>
       - A function to lookup the property from the return value of bean’s method (requires
       <code>
        camel-bean
       </code>
       JAR)
      </p>
     </li>
     <li>
      <p>
       <code>
        service
       </code>
       - A function to lookup the property from OS environment variables using the service naming idiom
      </p>
     </li>
     <li>
      <p>
       <code>
        service.name
       </code>
       - A function to lookup the property from OS environment variables using the service naming idiom returning the hostname part only
      </p>
     </li>
     <li>
      <p>
       <code>
        service.port
       </code>
       - A function to lookup the property from OS environment variables using the service naming idiom returning the port part only
      </p>
     </li>
    </ul>
   </div>
   <div class="paragraph">
    <p>
     These functions are intended to make it easy to lookup values from the environment, as shown in the example below:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext&gt;
    &lt;route&gt;
        &lt;from uri="direct:start"/&gt;
        &lt;to uri="{{env:SOMENAME}}"/&gt;
        &lt;to uri="{{sys:MyJvmPropertyName}}"/&gt;
    &lt;/route&gt;
&lt;/camelContext&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     You can use default values as well, so if the property does not exist, you can define a default value as shown below, where the default value is a
     <code>
      log:foo
     </code>
     and
     <code>
      log:bar
     </code>
     value.
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext&gt;
    &lt;route&gt;
        &lt;from uri="direct:start"/&gt;
        &lt;to uri="{{env:SOMENAME:log:foo}}"/&gt;
        &lt;to uri="{{sys:MyJvmPropertyName:log:bar}}"/&gt;
    &lt;/route&gt;
&lt;/camelContext&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     The service function is for looking up a service which is defined using OS environment variables using the service naming idiom, to refer to a service location using
     <code>
      hostname : port
     </code>
    </p>
   </div>
   <div class="ulist">
    <ul>
     <li>
      <p>
       <em>
        NAME
       </em>
       <strong>
        _SERVICE_HOST
       </strong>
      </p>
     </li>
     <li>
      <p>
       <em>
        NAME
       </em>
       <strong>
        _SERVICE_PORT
       </strong>
      </p>
     </li>
    </ul>
   </div>
   <div class="paragraph">
    <p>
     in other words the service uses
     <code>
      _SERVICE_HOST
     </code>
     and
     <code>
      _SERVICE_PORT
     </code>
     as prefix. So if the service is named FOO, then the OS environment variables should be set as
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-bash hljs" data-lang="bash">export $FOO_SERVICE_HOST=myserver
export $FOO_SERVICE_PORT=8888</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     For example if the FOO service a remote HTTP service, then we can refer to the service in the Camel endpoint uri, and use the HTTP component to make the HTTP call:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext&gt;
    &lt;route&gt;
        &lt;from uri="direct:start"/&gt;
        &lt;to uri="http://{{service:FOO}}/myapp"/&gt;
    &lt;/route&gt;
&lt;/camelContext&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     And we can use default values if the service has not been defined, for example to call a service on localhost, maybe for unit testing.
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext&gt;
&lt;route&gt;
    &lt;from uri="direct:start"/&gt;
    &lt;to uri="http://{{service:FOO:localhost:8080}}/myapp"/&gt;
&lt;/route&gt;
&lt;/camelContext&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     The bean function (you need to have
     <code>
      camel-bean
     </code>
     JAR on classpath) is for looking up the property from the return value of bean’s method.
    </p>
   </div>
   <div class="paragraph">
    <p>
     Assuming we have registered a bean named 'foo' that has a method called 'bar' that returns a directory name, then we can refer to the bean’s method in the camel endpoint url, and use the file component to poll a directory:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext&gt;
&lt;route&gt;
    &lt;from uri="file:{{bean:foo.bar}}"/&gt;
    &lt;to uri="direct:result"/&gt;
&lt;/route&gt;
&lt;/camelContext&gt;</code></pre>
    </div>
   </div>
   <div class="admonitionblock important">
    <div class="table-wrapper">
     <table>
      <tr>
       <td class="icon">
        <i class="fa icon-important" title="Important">
        </i>
       </td>
       <td class="content">
        The method must be a public no-arg method (i.e. no parameters) and return a value such as a String, boolean, int.
       </td>
      </tr>
     </table>
    </div>
   </div>
   <div class="sect2">
    <h3 id="_using_kubernetes_property_placeholder_functions">
     <a class="anchor" href="#_using_kubernetes_property_placeholder_functions">
     </a>
     Using Kubernetes property placeholder functions
    </h3>
    <div class="paragraph">
     <p>
      The
      <code>
       camel-kubernetes
      </code>
      component include the following functions:
     </p>
    </div>
    <div class="ulist">
     <ul>
      <li>
       <p>
        <code>
         configmap
        </code>
        - A function to lookup the string property from Kubernetes ConfigMaps.
       </p>
      </li>
      <li>
       <p>
        <code>
         configmap-binary
        </code>
        - A function to lookup the binary property from Kubernetes ConfigMaps.
       </p>
      </li>
      <li>
       <p>
        <code>
         secret
        </code>
        - A function to lookup the string property from Kubernetes Secrets.
       </p>
      </li>
      <li>
       <p>
        <code>
         secret-binary
        </code>
        - A function to lookup the binary property from Kubernetes Secrets.
       </p>
      </li>
     </ul>
    </div>
    <div class="paragraph">
     <p>
      The syntax for both functions are:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-none hljs">configmap:name/key[:defaultValue]</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      Where the default value is optional, for example the following will lookup
      <code>
       myKey
      </code>
      , and fail if there is no such configmap.
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-none hljs">configmap:mymap/mykey</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      In this example then it would not fail as a default value is provided:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-none hljs">configmap:mymap/mykey:123</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      If the value stored in the configmap is in binary format, so it is stored as
      <code>
       Binary Data
      </code>
      , it will be downloaded in a file, and it returns the absolute path of the file
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-none hljs">configmap-binary:mymap/mybinkey</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      it returns a path like
      <code>
       /tmp/camel11787545916150467474/mybinkey
      </code>
     </p>
    </div>
    <div class="paragraph">
     <p>
      Before the Kubernetes property placeholder functions can be used they need to be configured with either (or both)
     </p>
    </div>
    <div class="ulist">
     <ul>
      <li>
       <p>
        path - A
        <em>
         mount path
        </em>
        that must be mounted to the running pod, to load the configmaps or secrets from local disk.
       </p>
      </li>
      <li>
       <p>
        kubernetes client -
        <strong>
         Autowired
        </strong>
        An
        <code>
         io.fabric8.kubernetes.client.KubernetesClient
        </code>
        instance to use for connecting to the Kubernetes API server.
       </p>
      </li>
     </ul>
    </div>
    <div class="paragraph">
     <p>
      Camel will first use
      <em>
       mount paths
      </em>
      (if configured) to lookup, and then fallback to use the
      <code>
       KubernetesClient
      </code>
      .
     </p>
    </div>
    <div class="sect3">
     <h4 id="_configuring_mount_paths_for_configmaps_and_secrets">
      <a class="anchor" href="#_configuring_mount_paths_for_configmaps_and_secrets">
      </a>
      Configuring mount paths for ConfigMaps and Secrets
     </h4>
     <div class="paragraph">
      <p>
       The configuration of the
       <em>
        mount path
       </em>
       are used by the given order:
      </p>
     </div>
     <div class="olist arabic">
      <ol class="arabic">
       <li>
        <p>
         Reading configuration property with keys
         <code>
          camel.kubernetes-config.mount-path-configmaps
         </code>
         and
         <code>
          camel.kubernetes-config.mount-path-secrets
         </code>
         .
        </p>
       </li>
       <li>
        <p>
         Use JVM system property with key
         <code>
          camel.k.mount-path.configmaps
         </code>
         and
         <code>
          camel.k.mount-path.secrets
         </code>
         (Camel K compatible).
        </p>
       </li>
       <li>
        <p>
         Use OS ENV variable with key
         <code>
          CAMEL_K_MOUNT_PATH_CONFIGMAPS
         </code>
         and
         <code>
          CAMEL_K_MOUNT_PATH_SECRETS
         </code>
         (Camel K compatible).
        </p>
       </li>
      </ol>
     </div>
     <div class="paragraph">
      <p>
       For example to use
       <code>
        /etc/camel/resources/
       </code>
       as mount path, you can configure this in the
       <code>
        application.properties
       </code>
       :
      </p>
     </div>
     <div class="listingblock">
      <div class="content">
       <pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">camel.kubernetes-config.mount-path-configmaps = /etc/camel/myconfig/
camel.kubernetes-config.mount-path-secrets = /etc/camel/mysecrets/</code></pre>
      </div>
     </div>
    </div>
    <div class="sect3">
     <h4 id="_configuring_kubernetes_client">
      <a class="anchor" href="#_configuring_kubernetes_client">
      </a>
      Configuring Kubernetes Client
     </h4>
     <div class="paragraph">
      <p>
       Camel will autowire the
       <code>
        KubernetesClient
       </code>
       if a single instance of the client exists in the running application (lookup via the
       <a class="xref page" href="registry.html">
        Registry
       </a>
       ). Otherwise, a new
       <code>
        KubernetesClient
       </code>
       is created. The client can be configured from either
      </p>
     </div>
     <div class="ulist">
      <ul>
       <li>
        <p>
         Using
         <code>
          camel.kubernetes-config.client.
         </code>
         properties (see below for example)
        </p>
       </li>
       <li>
        <p>
         Attempt to auto-configure itself by a combination of OS Environment variables, reading from
         <code>
          ~./kube/config
         </code>
         configuration, and service account token file. For more details see the
         <a class="bare" href="https://github.com/fabric8io/kubernetes-client">
          https://github.com/fabric8io/kubernetes-client
         </a>
         documentation.
        </p>
       </li>
      </ul>
     </div>
     <div class="paragraph">
      <p>
       You most likely only need to explicit configure the
       <code>
        KubernetesClient
       </code>
       when you want to connect from a local computer to a remote Kubernetes cluster, where you can specify various options, such as the masterUrl and oauthToken as shown:
      </p>
     </div>
     <div class="listingblock">
      <div class="content">
       <pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">camel.kubernetes-config.client.masterUrl = https://127.0.0.1:50179/
camel.kubernetes-config.client.oauthToken = eyJhbGciOiJSUzI1NiIsImtpZCI...</code></pre>
      </div>
     </div>
     <div class="paragraph">
      <p>
       The
       <code>
        KubernetesClient
       </code>
       has many options, see the
       <a class="bare" href="https://github.com/fabric8io/kubernetes-client">
        https://github.com/fabric8io/kubernetes-client
       </a>
       documentation.
      </p>
     </div>
     <div class="paragraph">
      <p>
       If you only use
       <em>
        mount paths
       </em>
       , then it is good practice to disable
       <code>
        KubernetesClient
       </code>
       which can be done by setting enabled to false as show:
      </p>
     </div>
     <div class="listingblock">
      <div class="content">
       <pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">camel.kubernetes-config.client-enabled = false</code></pre>
      </div>
     </div>
     <div class="paragraph">
      <p>
       When running your Camel applications inside an existing Kubernetes cluster, then you often would not need to explicit configure the
       <code>
        KubernetesClient
       </code>
       and can rely on default settings.
      </p>
     </div>
     <div class="admonitionblock tip">
      <div class="table-wrapper">
       <table>
        <tr>
         <td class="icon">
          <i class="fa icon-tip" title="Tip">
          </i>
         </td>
         <td class="content">
          If you use Camel Quarkus, then it is recommended to use their
          <a class="bare" href="https://quarkus.io/guides/kubernetes-config">
           https://quarkus.io/guides/kubernetes-config
          </a>
          which automatic pre-configure the
          <code>
           KubernetesClient
          </code>
          which Camel then will reuse.
         </td>
        </tr>
       </table>
      </div>
     </div>
    </div>
    <div class="sect3">
     <h4 id="_using_configmap_with_kubernetes">
      <a class="anchor" href="#_using_configmap_with_kubernetes">
      </a>
      Using configmap with Kubernetes
     </h4>
     <div class="paragraph">
      <p>
       Given a configmap named
       <code>
        myconfig
       </code>
       in Kubernetes that has two entries:
      </p>
     </div>
     <div class="listingblock">
      <div class="content">
       <pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">drink = beer
first = Carlsberg</code></pre>
      </div>
     </div>
     <div class="paragraph">
      <p>
       Then these values can be used in your Camel routes such as:
      </p>
     </div>
     <div class="listingblock">
      <div class="content">
       <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext&gt;
  &lt;route&gt;
    &lt;from uri="direct:start"/&gt;
    &lt;log message="What {{configmap:myconfig/drink}} do you want?"/&gt;
    &lt;log message="I want {{configmap:myconfig/first}}"/&gt;
  &lt;/route&gt;
&lt;/camelContext&gt;</code></pre>
      </div>
     </div>
     <div class="paragraph">
      <p>
       You can also provide a default value in case a key does not exist:
      </p>
     </div>
     <div class="listingblock">
      <div class="content">
       <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">    &lt;log message="I want {{configmap:myconfig/second:Heineken}}"/&gt;</code></pre>
      </div>
     </div>
    </div>
    <div class="sect3">
     <h4 id="_using_secrets_with_kubernetes">
      <a class="anchor" href="#_using_secrets_with_kubernetes">
      </a>
      Using secrets with Kubernetes
     </h4>
     <div class="paragraph">
      <p>
       Camel reads ConfigMaps from the Kubernetes API Server. And when RBAC is enabled on the cluster, the ServiceAccount that is used to run the application needs to have the proper permissions for such access.
      </p>
     </div>
     <div class="paragraph">
      <p>
       A secret named
       <code>
        mydb
       </code>
       could contain username and passwords to connect to a database such as:
      </p>
     </div>
     <div class="listingblock">
      <div class="content">
       <pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">myhost = killroy
myport = 5555
myuser = scott
mypass = tiger</code></pre>
      </div>
     </div>
     <div class="paragraph">
      <p>
       This can be used in Camel with for example the Postrgres Sink Kamelet:
      </p>
     </div>
     <div class="listingblock">
      <div class="content">
       <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext&gt;
  &lt;route&gt;
    &lt;from uri="direct:rome"/&gt;
    &lt;setBody&gt;
      &lt;constant&gt;{ "username":"oscerd", "city":"Rome"}&lt;/constant&gt;
    &lt;/setBody&gt;
    &lt;to uri="kamelet:postgresql-sink?serverName={{secret:mydb/myhost}}
             &amp;amp;serverPort={{secret:mydb/myport}}
             &amp;amp;username={{secret:mydb/myuser}}
             &amp;amp;password={{secret:mydb/mypass}}
             &amp;amp;databaseName=cities
             &amp;amp;query=INSERT INTO accounts (username,city) VALUES (:#username,:#city)"/&gt;
  &lt;/route&gt;
&lt;/camelContext&gt;</code></pre>
      </div>
     </div>
     <div class="paragraph">
      <p>
       The postgres-sink Kamelet can also be configured in
       <code>
        application.properties
       </code>
       which reduces the configuration in the route above:
      </p>
     </div>
     <div class="listingblock">
      <div class="content">
       <pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">camel.component.kamelet.postgresql-sink.databaseName={{secret:mydb/myhost}}
camel.component.kamelet.postgresql-sink.serverPort={{secret:mydb/myport}}
camel.component.kamelet.postgresql-sink.username={{secret:mydb/myuser}}
camel.component.kamelet.postgresql-sink.password={{secret:mydb/mypass}}</code></pre>
      </div>
     </div>
     <div class="paragraph">
      <p>
       Which reduces the route to:
      </p>
     </div>
     <div class="listingblock">
      <div class="content">
       <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext&gt;
  &lt;route&gt;
    &lt;from uri="direct:rome"/&gt;
    &lt;setBody&gt;
      &lt;constant&gt;{ "username":"oscerd", "city":"Rome"}&lt;/constant&gt;
    &lt;/setBody&gt;
    &lt;to uri="kamelet:postgresql-sink?databaseName=cities
             &amp;amp;query=INSERT INTO accounts (username,city) VALUES (:#username,:#city)"/&gt;
  &lt;/route&gt;
&lt;/camelContext&gt;</code></pre>
      </div>
     </div>
    </div>
    <div class="sect3">
     <h4 id="_using_configmap_or_secrets_in_local_mode">
      <a class="anchor" href="#_using_configmap_or_secrets_in_local_mode">
      </a>
      Using configmap or secrets in local-mode
     </h4>
     <div class="paragraph">
      <p>
       During development you may want to run in
       <em>
        local mode
       </em>
       where you do not need acces to a Kubernetes cluster, to lookup the configmap. In the local mode, then Camel will lookup the configmap
       <em>
        keys
       </em>
       from local properties, eg:
      </p>
     </div>
     <div class="paragraph">
      <p>
       For example the example above with the postgresql kamelet, that was configured using a secret:
      </p>
     </div>
     <div class="listingblock">
      <div class="content">
       <pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">camel.component.kamelet.postgresql-sink.databaseName={{secret:mydb/myhost}}
camel.component.kamelet.postgresql-sink.serverPort={{secret:mydb/myport}}
camel.component.kamelet.postgresql-sink.username={{secret:mydb/myuser}}
camel.component.kamelet.postgresql-sink.password={{secret:mydb/mypass}}</code></pre>
      </div>
     </div>
     <div class="paragraph">
      <p>
       Now suppose we have a local Postrgres database we want to use, then we can turn on
       <em>
        local mode
       </em>
       and specify the credentials in the same properties file:
      </p>
     </div>
     <div class="listingblock">
      <div class="content">
       <pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">camel.kubernetes-config.local-mode = true
mydb/myhost=localhost
mydb/myport=1234
mydb/myuser=scott
mydb/mypass=tiger</code></pre>
      </div>
     </div>
     <div class="admonitionblock note">
      <div class="table-wrapper">
       <table>
        <tr>
         <td class="icon">
          <i class="fa icon-note" title="Note">
          </i>
         </td>
         <td class="content">
          Notice how the key is prefixed with the name of the secret and a slash, eg
          <code>
           name/key
          </code>
          . This makes it easy to copy/paste from the actual use of the configmap/secret and into the
          <code>
           application.properties
          </code>
          file.
         </td>
        </tr>
       </table>
      </div>
     </div>
    </div>
   </div>
   <div class="sect2">
    <h3 id="_using_custom_property_placeholder_functions">
     <a class="anchor" href="#_using_custom_property_placeholder_functions">
     </a>
     Using custom property placeholder functions
    </h3>
    <div class="paragraph">
     <p>
      The
      <a class="xref page" href="../components/4.10.x/properties-component.html">
       Properties
      </a>
      component allow to plugin 3rd party functions which can be used during parsing of the property placeholders. These functions are then able to do custom logic to resolve the placeholders, such as looking up in databases, do custom computations, or whatnot. The name of the function becomes the prefix used in the placeholder.
     </p>
    </div>
    <div class="paragraph">
     <p>
      This is best illustrated in the example route below, where we use
      <code>
       beer
      </code>
      as the prefix:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;route&gt;
    &lt;from uri="direct:start"/&gt;
    &lt;to uri="{{beer:FOO}}"/&gt;
    &lt;to uri="{{beer:BAR}}"/&gt;
&lt;/route&gt;</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      The implementation of the function is only two methods as shown below:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@org.apache.camel.spi.annotations.PropertiesFunction("beer")
public class MyBeerFunction implements PropertiesFunction {

    @Override
    public String getName() {
        return "beer";
    }

    @Override
    public String apply(String remainder) {
        return "mock:" + remainder.toLowerCase();
    }
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      The function must implement the
      <code>
       org.apache.camel.spi.PropertiesFunction
      </code>
      interface. The method
      <code>
       getName
      </code>
      is the name of the function (beer). And the
      <code>
       apply
      </code>
      method is where we implement the custom logic to do. As the sample code is from a unit test, it just returns a value to refer to a mock endpoint.
     </p>
    </div>
    <div class="paragraph">
     <p>
      You also need to have
      <code>
       camel-component-maven-plugin
      </code>
      as part of building the component will then ensure that this custom properties function has necessary source code generated that makes Camel able to automatically discover the function.
     </p>
    </div>
    <div class="admonitionblock note">
     <div class="table-wrapper">
      <table>
       <tr>
        <td class="icon">
         <i class="fa icon-note" title="Note">
         </i>
        </td>
        <td class="content">
         If the custom properties function need logic to startup and shutdown, then the function can extend
         <code>
          ServiceSupport
         </code>
         and have this logic in
         <code>
          doStart
         </code>
         and
         <code>
          doStop
         </code>
         methods.
        </td>
       </tr>
      </table>
     </div>
    </div>
    <div class="admonitionblock tip">
     <div class="table-wrapper">
      <table>
       <tr>
        <td class="icon">
         <i class="fa icon-tip" title="Tip">
         </i>
        </td>
        <td class="content">
         For an example see the
         <code>
          camel-base64
         </code>
         component.
        </td>
       </tr>
      </table>
     </div>
    </div>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="_using_third_party_property_sources">
   <a class="anchor" href="#_using_third_party_property_sources">
   </a>
   Using third party property sources
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     The properties component allows to plugin 3rd party sources to load and lookup properties via the
     <code>
      PropertySource
     </code>
     API from camel-api.
    </p>
   </div>
   <div class="paragraph">
    <p>
     The regular
     <code>
      PropertySource
     </code>
     will lookup the property on-demand, for example to lookup values from a backend source such as a database or HashiCorp Vault etc.
    </p>
   </div>
   <div class="paragraph">
    <p>
     A
     <code>
      PropertySource
     </code>
     can define that it supports loading all its properties (by implementing
     <code>
      LoadablePropertiesSource
     </code>
     ) from the source at once, for example from file system. This allows Camel properties component to load these properties at once during startup.
    </p>
   </div>
   <div class="paragraph">
    <p>
     For example the
     <code>
      camel-microprofile-config
     </code>
     component is implemented using this. The 3rd-party
     <code>
      PropertySource
     </code>
     can automatically be discovered from classpath when Camel is starting up. This is done by including the file
     <code>
      META-INF/services/org/apache/camel/property-source-factory
     </code>
     which refers to the fully qualified class name of the
     <code>
      PropertySource
     </code>
     implementation.
    </p>
   </div>
   <div class="paragraph">
    <p>
     See
     <a class="xref page" href="../components/4.10.x/others/microprofile-config.html">
      MicroProfile Config
     </a>
     component as an example.
    </p>
   </div>
   <div class="paragraph">
    <p>
     You can also register 3rd-party property sources via Java API:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">PropertiesComponent pc = context.getPropertiesComponent();
pc.addPropertiesSource(myPropertySource);</code></pre>
    </div>
   </div>
  </div>
 </div>
</article>
