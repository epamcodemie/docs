<article class="doc">
 <h1 class="page">
  Route Template
 </h1>
 <div id="preamble">
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     A Route template is as its name implies a template for a route, which is used to create routes from a set of input parameters. In other words, route templates are parameterized routes.
    </p>
   </div>
   <div class="paragraph">
    <p>
     <em>
      Route template
     </em>
     +
     <em>
      input parameters
     </em>
     â‡’
     <em>
      route
     </em>
    </p>
   </div>
   <div class="paragraph">
    <p>
     From a route template, you can create one or more routes.
    </p>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="_defining_route_templates_in_the_dsl">
   <a class="anchor" href="#_defining_route_templates_in_the_dsl">
   </a>
   Defining route templates in the DSL
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     Route templates are to be defined in the DSL (just like routes) as shown in the following:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyRouteTemplates extends RouteBuilder {

    @Override
    public void configure() throws Exception {
        // create a route template with the given name
        routeTemplate("myTemplate")
            // here we define the required input parameters (can have default values)
            .templateParameter("name")
            .templateParameter("greeting")
            .templateParameter("myPeriod", "3s")
            // here comes the route in the template
            // notice how we use {{name}} to refer to the template parameters
            // we can also use {{propertyName}} to refer to property placeholders
            .from("timer:{{name}}?period={{myPeriod}}")
                .setBody(simple("{{greeting}} ${body}"))
                .log("${body}");
    }
}</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     And in Spring XML DSL
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext&gt;
  &lt;routeTemplate id="myTemplate"&gt;
    &lt;templateParameter name="name"/&gt;
    &lt;templateParameter name="greeting"/&gt;
    &lt;templateParameter name="myPeriod" defaultValue="3s"/&gt;
    &lt;route&gt;
      &lt;from uri="timer:{{name}}?period={{myPeriod}}"/&gt;
      &lt;setBody&gt;&lt;simple&gt;{{greeting}} ${body}&lt;/simple&gt;&lt;/setBody&gt;
      &lt;log message="${body}"/&gt;
    &lt;/route&gt;
  &lt;/routeTemplate&gt;
&lt;/camelContext&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     And in XML DSL
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;routeTemplates xmlns="http://camel.apache.org/schema/spring"&gt;
    &lt;routeTemplate id="myTemplate"&gt;
        &lt;templateParameter name="name"/&gt;
        &lt;templateParameter name="greeting"/&gt;
        &lt;templateParameter name="myPeriod" defaultValue="3s"/&gt;
        &lt;route&gt;
            &lt;from uri="timer:{{name}}?period={{myPeriod}}"/&gt;
            &lt;setBody&gt;&lt;simple&gt;{{greeting}} ${body}&lt;/simple&gt;&lt;/setBody&gt;
            &lt;log message="${body}"/&gt;
        &lt;/route&gt;
    &lt;/routeTemplate&gt;
&lt;/routeTemplates&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     In the examples above, there was one route template, but you can define as many as you want. Each template must have a unique id. The template parameters are used for defining the parameters the template accepts. As you can see, there are three parameters:
     <code>
      <em>
       name
      </em>
     </code>
     ,
     <code>
      <em>
       greeting
      </em>
     </code>
     , and
     <code>
      <em>
       myPeriod
      </em>
     </code>
     . The first two parameters are mandatory, whereas
     <code>
      <em>
       myPeriod
      </em>
     </code>
     is optional as it has a default value of 3s.
    </p>
   </div>
   <div class="paragraph">
    <p>
     The template parameters are then used in the route as regular property placeholders with the
     <code>
      {{ }}
     </code>
     syntax. Notice how we use
     <code>
      {{name}}
     </code>
     and
     <code>
      {{greeting}}
     </code>
     in the timer endpoint and the simple language.
    </p>
   </div>
   <div class="paragraph">
    <p>
     The route can, of course, use regular property placeholders as well. Now imagine there was a property placeholder with the name greeting:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">greeting = Davs</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     Then Camel would normally have used this value
     <code>
      Davs
     </code>
     when creating the route. However, as the route template has defined a template parameter with the same name
     <code>
      greeting
     </code>
     then a value must be provided when creating routes from the template.
    </p>
   </div>
   <div class="paragraph">
    <p>
     Template parameters take precedence over regular property placeholders.
    </p>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="_creating_a_route_from_a_route_template">
   <a class="anchor" href="#_creating_a_route_from_a_route_template">
   </a>
   Creating a route from a route template
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     To create routes from route templates, then you should use
     <code>
      org.apache.camel.builder.TemplatedRouteBuilder
     </code>
     .
    </p>
   </div>
   <div class="paragraph">
    <p>
     In the following code snippet, you can see how this is done with the builder:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// create two routes from the template
TemplatedRouteBuilder.builder(context, "myTemplate")
    .parameter("name", "one")
    .parameter("greeting", "Hello")
    .add();

TemplatedRouteBuilder.builder(context, "myTemplate")
    .parameter("name", "two")
    .parameter("greeting", "Bonjour")
    .parameter("myPeriod", "5s")
    .add();</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     And in Java DSL:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">templatedRoute("myTemplate")
        .parameter("name", "one")
        .parameter("greeting", "Hello");
templatedRoute("myTemplate")
        .parameter("name", "two")
        .parameter("greeting", "Bonjour")
        .parameter("myPeriod", "5s");</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     And in Spring XML DSL:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext&gt;
  &lt;templatedRoute routeTemplateRef="myTemplate"&gt;
    &lt;parameter name="name" value="one"/&gt;
    &lt;parameter name="greeting" value="Hello"/&gt;
  &lt;/templatedRoute&gt;
  &lt;templatedRoute routeTemplateRef="myTemplate"&gt;
    &lt;parameter name="name" value="two"/&gt;
    &lt;parameter name="greeting" value="Bonjour"/&gt;
    &lt;parameter name="myPeriod" value="5s"/&gt;
  &lt;/templatedRoute&gt;
&lt;/camelContext&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     And in XML DSL:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;templatedRoutes xmlns="http://camel.apache.org/schema/spring"&gt;
  &lt;templatedRoute routeTemplateRef="myTemplate"&gt;
    &lt;parameter name="name" value="one"/&gt;
    &lt;parameter name="greeting" value="Hello"/&gt;
  &lt;/templatedRoute&gt;
  &lt;templatedRoute routeTemplateRef="myTemplate"&gt;
    &lt;parameter name="name" value="two"/&gt;
    &lt;parameter name="greeting" value="Bonjour"/&gt;
    &lt;parameter name="myPeriod" value="5s"/&gt;
  &lt;/templatedRoute&gt;
&lt;/templatedRoutes&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     And in YAML DSL:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">- templated-route:
    route-template-ref: "myTemplate"
    parameters:
      - name: "name"
        value: "one"
      - name: "greeting"
        value: "Hello"
- templated-route:
    route-template-ref: "myTemplate"
    parameters:
      - name: "name"
        value: "two"
      - name: "greeting"
        value: "Bonjour"
      - name: "myPeriod"
        value: "5s"</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     The returned value from
     <code>
      add
     </code>
     is the route id of the new route that was added. However
     <code>
      null
     </code>
     is returned if the route is not yet created and added, which can happen if
     <code>
      CamelContext
     </code>
     is not started yet.
    </p>
   </div>
   <div class="paragraph">
    <p>
     If no route id is provided, then Camel will auto assign a route id. In the example above then Camel would assign route ids such as
     <code>
      route1
     </code>
     ,
     <code>
      route2
     </code>
     to these routes.
    </p>
   </div>
   <div class="paragraph">
    <p>
     If you want to specify a route id, then use
     <code>
      routeId
     </code>
     as follows, where the id is set to myCoolRoute:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">TemplatedRouteBuilder.builder(context, "myTemplate")
    .routeId("myCoolRoute")
    .parameter("name", "one")
    .parameter("greeting", "hello")
    .parameter("myPeriod", "5s")
    .add();</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     And in Java DSL:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">templatedRoute("myTemplate")
        .routeId("myCoolRoute")
        .parameter("name", "one")
        .parameter("greeting", "hello")
        .parameter("myPeriod", "5s");</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     And in Spring XML DSL:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext&gt;
  &lt;templatedRoute routeTemplateRef="myTemplate" routeId="myCoolRoute"&gt;
    &lt;parameter name="name" value="one"/&gt;
    &lt;parameter name="greeting" value="hello"/&gt;
    &lt;parameter name="myPeriod" value="5s"/&gt;
  &lt;/templatedRoute&gt;
&lt;/camelContext&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     And in XML DSL:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;templatedRoutes xmlns="http://camel.apache.org/schema/spring"&gt;
  &lt;templatedRoute routeTemplateRef="myTemplate" routeId="myCoolRoute"&gt;
    &lt;parameter name="name" value="one"/&gt;
    &lt;parameter name="greeting" value="hello"/&gt;
    &lt;parameter name="myPeriod" value="5s"/&gt;
  &lt;/templatedRoute&gt;
&lt;/templatedRoutes&gt;</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     And in YAML DSL:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">- templated-route:
    route-template-ref: "myTemplate"
    route-id: "myCoolRoute"
    parameters:
      - name: "name"
        value: "one"
      - name: "greeting"
        value: "hello"
      - name: "myPeriod"
        value: "5s"</code></pre>
    </div>
   </div>
   <div class="sect2">
    <h3 id="_using_template_parameters_with_java_dsl_simple_builder">
     <a class="anchor" href="#_using_template_parameters_with_java_dsl_simple_builder">
     </a>
     Using template parameters with Java DSL simple builder
    </h3>
    <div class="paragraph">
     <p>
      When using Java DSL and simple language, then beware that you should not use the
      <em>
       simple fluent builder
      </em>
      when defining the simple expressions/predicates.
     </p>
    </div>
    <div class="paragraph">
     <p>
      For example, given the following route template in Java DSL:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyRouteTemplates extends RouteBuilder {

    @Override
    public void configure() throws Exception {
        routeTemplate("myTemplate")
            .templateParameter("name")
            .templateParameter("color")
            .from("direct:{{name}}")
                .choice()
                    .when(simple("{{color}}").isEqualTo("red"))
                        .to("direct:red")
                    .otherwise()
                        .to("color:other")
                .end();
    }
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      Then notice how the simple predicate is using
      <em>
       simple fluent builder
      </em>
      <code>
       simple("{{color}}").isEqualTo("red")
      </code>
      . This is
      <strong>
       not supported
      </strong>
      with route templates and would not work when creating multiple routes from the template.
     </p>
    </div>
    <div class="paragraph">
     <p>
      Instead, the simple expression should be a literal String value
      <em>
       only
      </em>
      as follows:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre>    .when(simple("'{{color}}' == 'red'")</pre>
     </div>
    </div>
   </div>
   <div class="sect2">
    <h3 id="_using_hardcoded_node_ids_in_route_templates">
     <a class="anchor" href="#_using_hardcoded_node_ids_in_route_templates">
     </a>
     Using hardcoded node IDs in route templates
    </h3>
    <div class="paragraph">
     <p>
      If route templates contain hardcoded node IDs, then routes created from templates will use the same IDs. Therefore, if two or more routes are created from the same template, you will have
      <em>
       duplicate id detected
      </em>
      error.
     </p>
    </div>
    <div class="paragraph">
     <p>
      Given the route template below, then it has hardcoded ID (
      <code>
       <em>
        new-order
       </em>
      </code>
      ) in node calling the http services.
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyRouteTemplates extends RouteBuilder {

    @Override
    public void configure() throws Exception {
        routeTemplate("orderTemplate")
            .templateParameter("queue")
            .from("jms:{{queue}}")
                .to("http:orderserver.acme.com/neworder").id("new-order")
                .log("Processing order");
    }
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      When creating routes from templates, you can then provide a
      <em>
       prefix
      </em>
      which is used for all node IDs. This allows to create 2 or more routes without
      <em>
       duplicate id
      </em>
      errors.
     </p>
    </div>
    <div class="paragraph">
     <p>
      For example in the following, we create a new route
      <code>
       <em>
        myCoolRoute
       </em>
      </code>
      from the
      <code>
       <em>
        myTemplate
       </em>
      </code>
      template, and use a prefix of
      <code>
       <em>
        web
       </em>
      </code>
      .
     </p>
    </div>
    <div class="paragraph">
     <p>
      And in Java DSL
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">templatedRoute("orderTemplate")
        .routeId("webOrder")
        .prefixId("web")
        .parameter("queue", "order.web");</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      Then we can create a 2nd route:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">templatedRoute("orderTemplate")
        .routeId("ftpOrder")
        .prefixId("ftp")
        .parameter("queue", "order.ftp");</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      And in Spring XML DSL:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext&gt;
  &lt;templatedRoute routeTemplateRef="orderTemplate" routeId="webOrder" prefixId="web"&gt;
    &lt;parameter name="queue" value="web"/&gt;
  &lt;/templatedRoute&gt;
&lt;/camelContext&gt;</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      And in XML DSL:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;templatedRoutes xmlns="http://camel.apache.org/schema/spring"&gt;
  &lt;templatedRoute routeTemplateRef="orderTemplate" routeId="webOrder" prefixId="web"&gt;
    &lt;parameter name="queue" value="web"/&gt;
  &lt;/templatedRoute&gt;
&lt;/templatedRoutes&gt;</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      And in YAML DSL:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">- templated-route:
    route-template-ref: "orderTemplate"
    route-id: "webOrder"
    prefix-id: "web"
    parameters:
      - name: "queue"
        value: "web"</code></pre>
     </div>
    </div>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="_binding_beans_to_route_template">
   <a class="anchor" href="#_binding_beans_to_route_template">
   </a>
   Binding beans to route template
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     The route template allows binding beans that are locally scoped and only used as part of creating routes from the template. This allows using the same template to create multiple routes, where beans are local (private) for each created route.
    </p>
   </div>
   <div class="paragraph">
    <p>
     For example, given the following route template where we use
     <code>
      templateBean
     </code>
     to set up the local bean as shown:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">routeTemplate("s3template")
    .templateParameter("region")
    .templateParameter("bucket")
    .templateBean("myClient", S3Client.class, rtc -&gt;
            S3Client.builder().region(rtc.getProperty("region", Region.class)).build();
    )
    .from("direct:s3-store")
     // must refer to the bean with {{myClient}}
    .to("aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}")</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     The template has two parameters to specify the AWS region and the S3 bucket. To connect to S3 then a
     <code>
      software.amazon.awssdk.services.s3.S3Client
     </code>
     bean is necessary.
    </p>
   </div>
   <div class="paragraph">
    <p>
     To create this bean, we specify this with the
     <code>
      templateBean
     </code>
     DSL where we specify the bean id as
     <code>
      myClient
     </code>
     . The type of the bean can be specified (
     <code>
      S3Client.class
     </code>
     ), however, it is optional (can be used if you need to let beans be discovered by type and not by name).
    </p>
   </div>
   <div class="paragraph">
    <p>
     This ensures that the code creating the bean is executed later (when Camel is creating a route from the template), then the code must be specified as a
     <em>
      supplier
     </em>
     . Because we want during creation of the bean access to template parameters, we use a Camel
     <code>
      BeanSupplier
     </code>
     which gives access to
     <code>
      RouteTemplateContext
     </code>
     that is the
     <code>
      <em>
       rtc
      </em>
     </code>
     variable in the code above.
    </p>
   </div>
   <div class="admonitionblock important">
    <div class="table-wrapper">
     <table>
      <tr>
       <td class="icon">
        <i class="fa icon-important" title="Important">
        </i>
       </td>
       <td class="content">
        The local bean with id
        <code>
         myClient
        </code>
        <strong>
         must
        </strong>
        be referred to using Camelâ€™s property placeholder syntax, eg
        <code>
         {{myClient}}
        </code>
        in the route template, as shown above with the
        <em>
         to
        </em>
        endpoint. This is because the local bean must be made unique and Camel will internally re-assign the bean id to use a unique id instead of
        <code>
         myClient
        </code>
        . And this is done with the help of the property placeholder functionality.
       </td>
      </tr>
     </table>
    </div>
   </div>
   <div class="paragraph">
    <p>
     If multiple routes are created from this template, then each of the created routes have their own
     <code>
      S3Client
     </code>
     bean created.
    </p>
   </div>
   <div class="sect2">
    <h3 id="_binding_beans_to_route_templates_from_template_builder">
     <a class="anchor" href="#_binding_beans_to_route_templates_from_template_builder">
     </a>
     Binding beans to route templates from template builder
    </h3>
    <div class="paragraph">
     <p>
      The
      <code>
       TemplatedRouteBuilder
      </code>
      also allows to bind local beans (which allows specifying those beans) when creating routes from existing templates.
     </p>
    </div>
    <div class="paragraph">
     <p>
      Suppose the route template below is defined in XML:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext&gt;
  &lt;routeTemplate id="s3template"&gt;
    &lt;templateParameter name="region"/&gt;
    &lt;templateParameter name="bucket"/&gt;
    &lt;route&gt;
      &lt;from uri="direct:s3-store"/&gt;
      &lt;to uri="aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}"/&gt;
    &lt;/route&gt;
  &lt;/routeTemplate&gt;
&lt;/camelContext&gt;</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      The template has no bean bindings for
      <code>
       #{{myClient}}
      </code>
      which would be required for creating the template.
     </p>
    </div>
    <div class="paragraph">
     <p>
      When creating routes form the template via
      <code>
       TemplatedRouteBuilder
      </code>
      then you can provide the bean binding if you desire the bean to be locally scoped (not shared with others):
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">TemplatedRouteBuilder.builder(context, "s3template")
    .parameter("region", "US-EAST-1")
    .parameter("bucket", "myBucket")
    .bean("myClient", S3Client.class,
                S3Client.builder()
                    .region(rtc.getProperty("region", Region.class))
                    .build())
    .routeId("mys3route")
    .add();</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      As you can see the binding is similar to when using
      <code>
       templateBean
      </code>
      directly in the route template.
     </p>
    </div>
    <div class="paragraph">
     <p>
      And in Java DSL:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">templatedRoute("s3template")
        .parameter("region", "US-EAST-1")
        .parameter("bucket", "myBucket")
        .bean("myClient", S3Client.class,
                rtc -&gt; S3Client.builder() <i class="conum" data-value="1"></i><b>(1)</b>
                    .region(rtc.getProperty("region", Region.class))
                    .build())
        .routeId("mys3route");</code></pre>
     </div>
    </div>
    <div class="colist arabic">
     <div class="table-wrapper">
      <table>
       <tr>
        <td>
         <i class="conum" data-value="1">
         </i>
         <b>
          1
         </b>
        </td>
        <td>
         Note that the third parameter of the
         <code>
          bean
         </code>
         method is not directly the bean but rather a factory method that will be used to create the bean, here we use a lambda expression as factory method.
        </td>
       </tr>
      </table>
     </div>
    </div>
    <div class="paragraph">
     <p>
      And in XML DSL:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">  &lt;templatedRoute routeTemplateRef="s3template" routeId="mys3route"&gt;
    &lt;parameter name="region" value="US-EAST-1"/&gt;
    &lt;parameter name="bucket" value="myBucket"/&gt;
    &lt;bean name="myClient" type="software.amazon.awssdk.services.s3.S3Client"
          scriptLanguage="groovy"&gt; <i class="conum" data-value="1"></i><b>(1)</b>
        &lt;script&gt;
            import software.amazon.awssdk.services.s3.S3Client
            S3Client.builder()
                .region(rtc.getProperty("region", Region.class))
                .build()
        &lt;/script&gt;
    &lt;/bean&gt;
  &lt;/templatedRoute&gt;</code></pre>
     </div>
    </div>
    <div class="colist arabic">
     <div class="table-wrapper">
      <table>
       <tr>
        <td>
         <i class="conum" data-value="1">
         </i>
         <b>
          1
         </b>
        </td>
        <td>
         For non-Java DSL, in case of a complex bean factory, you can still rely on a language like
         <code>
          groovy
         </code>
         to define your bean factory inside a
         <code>
          script
         </code>
         element.
        </td>
       </tr>
      </table>
     </div>
    </div>
    <div class="paragraph">
     <p>
      And in YAML DSL:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">- templated-route:
    route-template-ref: "s3template"
    route-id: "mys3route"
    parameters:
      - name: "region"
        value: "US-EAST-1"
      - name: "bucket"
        value: "myBucket"
    beans:
      - name: "myClient"
        type: "software.amazon.awssdk.services.s3.S3Client"
        scriptLanguage: "groovy"
        script: | <i class="conum" data-value="1"></i><b>(1)</b>
            import software.amazon.awssdk.services.s3.S3Client
            S3Client.builder()
                .region(rtc.getProperty("region", Region.class))
                .build()</code></pre>
     </div>
    </div>
    <div class="colist arabic">
     <div class="table-wrapper">
      <table>
       <tr>
        <td>
         <i class="conum" data-value="1">
         </i>
         <b>
          1
         </b>
        </td>
        <td>
         For non-Java DSL, in case of a complex bean factory, you can still rely on a language like
         <code>
          groovy
         </code>
         to define your bean factory as value of the
         <code>
          script
         </code>
         key.
        </td>
       </tr>
      </table>
     </div>
    </div>
    <div class="paragraph">
     <p>
      Instead of binding the beans from the template builder, you could also create the bean outside the template, and bind it by reference.
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">final S3Client myClient = S3Client.builder().region(Region.US_EAST_1).build();

TemplatedRouteBuilder.builder(context, "s3template")
    .parameter("region", Region.US_EAST_1)
    .parameter("bucket", "myBucket")
    .bean("myClient", myClient)
    .routeId("mys3route")
    .add();</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      And in Java DSL:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">templatedRoute("s3template")
        .parameter("region", "US-EAST-1")
        .parameter("bucket", "myBucket")
        .bean("myClient", S3Client.class, rtc -&gt; myClient)
        .routeId("mys3route");</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      You should prefer to create the local beans directly from within the template (if possible) because this ensures the route template has this out of the box. Otherwise, the bean must be created or provided every time a new route is created from the route template. However, the latter gives freedom to create the bean in any other custom way.
     </p>
    </div>
   </div>
   <div class="sect2">
    <h3 id="_binding_beans_to_route_templates_using_bean_types">
     <a class="anchor" href="#_binding_beans_to_route_templates_using_bean_types">
     </a>
     Binding beans to route templates using bean types
    </h3>
    <div class="paragraph">
     <p>
      You can create a local bean by referring to a fully qualified class name which Camel will use to create a new local bean instance. When using this, the created bean is created via default constructor of the class.
     </p>
    </div>
    <div class="paragraph">
     <p>
      The bean instance can be configured with properties via getter/setter style. The previous example with creating the AWS S3Client would not support this kind as this uses
      <em>
       fluent builder
      </em>
      pattern (not getter/setter).
     </p>
    </div>
    <div class="admonitionblock tip">
     <div class="table-wrapper">
      <table>
       <tr>
        <td class="icon">
         <i class="fa icon-tip" title="Tip">
         </i>
        </td>
        <td class="content">
         In
         <strong>
          Camel 4.6
         </strong>
         onwards, you can also use constructor arguments for beans
        </td>
       </tr>
      </table>
     </div>
    </div>
    <div class="paragraph">
     <p>
      So suppose we have a class as follows:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class MyBar {
    private String name;
    private String address;

    // getter/setter omitted

    public String location() {
        return "The bar " + name + " is located at " + address;
    }
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      Then we can use the
      <code>
       MyBar
      </code>
      class as a local bean in a route template as follows:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">routeTemplate("barTemplate")
    .templateParameter("bar")
    .templateParameter("street")
    .templateBean("myBar")
        .typeClass("com.foo.MyBar")
        .property("name", "{{bar}}")
        .property("address", "{{street}}")
    .end()
    .from("direct:going-out")
    .to("bean:{{myBar}}")</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      With Java DSL, you can also refer to the bean class using type safe way:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">.templateBean("myBar")
    .typeClass(MyBar.class)
    .property("name", "{{bar}}")
    .property("address", "{{street}}")
.end()</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      In XML DSL you would do:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext xmlns="http://camel.apache.org/schema/spring"&gt;
    &lt;routeTemplate id="myBar"&gt;
        &lt;templateParameter name="bar"/&gt;
        &lt;templateParameter name="street"/&gt;
        &lt;templateBean name="myBean" type="#class:com.foo.MyBar"&gt;
            &lt;properties&gt;
                &lt;property key="name" value="{{bar}}"/&gt;
                &lt;property key="address" value="{{street}}"/&gt;
            &lt;/properties&gt;
        &lt;/templateBean&gt;
        &lt;route&gt;
            &lt;from uri="direct:going-out"/&gt;
            &lt;to uri="bean:{{myBar}}"/&gt;
        &lt;/route&gt;
    &lt;/routeTemplate&gt;
&lt;/camelContext&gt;</code></pre>
     </div>
    </div>
   </div>
   <div class="sect2">
    <h3 id="_binding_beans_to_route_templates_using_scripting_languages">
     <a class="anchor" href="#_binding_beans_to_route_templates_using_scripting_languages">
     </a>
     Binding beans to route templates using scripting languages
    </h3>
    <div class="paragraph">
     <p>
      You can use scripting languages like groovy, java, mvel to create the bean. This allows defining route templates with the scripting language built-in (such as groovy).
     </p>
    </div>
    <div class="paragraph">
     <p>
      For example, creating the AWS S3 client can be done as shown in Java (with inlined groovy code):
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">routeTemplate("s3template")
    .templateParameter("region")
    .templateParameter("bucket")
    .templateBean("myClient", "groovy",
            "software.amazon.awssdk.services.s3.S3Client.S3Client.builder()
            .region(rtc.getProperty("region", Region.class))
            .build()"
    )
    .from("direct:s3-store")
     // must refer to the bean with {{myClient}}
    .to("aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}")</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      The groovy code can be externalized into a file on the classpath or file system, by using
      <code>
       resource:
      </code>
      as prefix, such as:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">routeTemplate("s3template")
    .templateParameter("region")
    .templateParameter("bucket")
    .templateBean("myClient", "groovy", "resource:classpath:s3bean.groovy")
    .from("direct:s3-store")
     // must refer to the bean with {{myClient}}
    .to("aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}")</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      Then create the file
      <code>
       s3bean.groovy
      </code>
      in the classpath root:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">import software.amazon.awssdk.services.s3.S3Client
S3Client.builder()
    .region(rtc.getProperty("region", Region.class))
    .build()</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      The route template in XML DSL can then also use groovy language to create the bean as follows:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext&gt;
  &lt;routeTemplate id="s3template"&gt;
    &lt;templateParameter name="region"/&gt;
    &lt;templateParameter name="bucket"/&gt;
    &lt;templateBean name="myClient" type="groovy"&gt;
        &lt;script&gt;
            import software.amazon.awssdk.services.s3.S3Client
            S3Client.builder()
                .region(rtc.getProperty("region", Region.class))
                .build()
        &lt;/script&gt;
    &lt;/templateBean&gt;
    &lt;route&gt;
      &lt;from uri="direct:s3-store"/&gt;
      &lt;to uri="aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}"/&gt;
    &lt;/route&gt;
  &lt;/routeTemplate&gt;
&lt;/camelContext&gt;</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      Notice how the groovy code can be inlined directly in the route template in XML also. Of course, you can also externalize the bean creation code to an external file, by using
      <code>
       resource:
      </code>
      as prefix:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext&gt;
  &lt;routeTemplate id="s3template"&gt;
    &lt;templateParameter name="region"/&gt;
    &lt;templateParameter name="bucket"/&gt;
    &lt;templateBean name="myClient" type="groovy"&gt;
        &lt;script&gt;resource:classpath:s3bean.groovy&lt;/script&gt;
    &lt;/templateBean&gt;
    &lt;route&gt;
      &lt;from uri="direct:s3-store"/&gt;
      &lt;to uri="aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}"/&gt;
    &lt;/route&gt;
  &lt;/routeTemplate&gt;
&lt;/camelContext&gt;</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      The languages supported are:
     </p>
    </div>
    <div class="table-wrapper">
     <table class="tableblock frame-all grid-all stretch">
      <colgroup>
       <col/>
       <col/>
      </colgroup>
      <thead>
       <tr>
        <th class="tableblock halign-left valign-top">
         Type
        </th>
        <th class="tableblock halign-left valign-top">
         Description
        </th>
       </tr>
      </thead>
      <tbody>
       <tr>
        <td class="tableblock halign-left valign-top">
         <p class="tableblock">
          <strong>
           bean
          </strong>
         </p>
        </td>
        <td class="tableblock halign-left valign-top">
         <p class="tableblock">
          Calling a method on a Java class to create the bean.
         </p>
        </td>
       </tr>
       <tr>
        <td class="tableblock halign-left valign-top">
         <p class="tableblock">
          <strong>
           groovy
          </strong>
         </p>
        </td>
        <td class="tableblock halign-left valign-top">
         <p class="tableblock">
          Using a groovy script to create the bean.
         </p>
        </td>
       </tr>
       <tr>
        <td class="tableblock halign-left valign-top">
         <p class="tableblock">
          <strong>
           java
          </strong>
         </p>
        </td>
        <td class="tableblock halign-left valign-top">
         <p class="tableblock">
          Java code which is runtime compiled (using jOOR library) to create the bean.
         </p>
        </td>
       </tr>
       <tr>
        <td class="tableblock halign-left valign-top">
         <p class="tableblock">
          <strong>
           mvel
          </strong>
         </p>
        </td>
        <td class="tableblock halign-left valign-top">
         <p class="tableblock">
          To use a Mvel template script to create the bean.
         </p>
        </td>
       </tr>
       <tr>
        <td class="tableblock halign-left valign-top">
         <p class="tableblock">
          <strong>
           ognl
          </strong>
         </p>
        </td>
        <td class="tableblock halign-left valign-top">
         <p class="tableblock">
          To use OGNL template script to create the bean.
         </p>
        </td>
       </tr>
       <tr>
        <td class="tableblock halign-left valign-top">
         <p class="tableblock">
          <strong>
           <em>
            name
           </em>
          </strong>
         </p>
        </td>
        <td class="tableblock halign-left valign-top">
         <p class="tableblock">
          To use a third-party language by the given
          <code>
           <em>
            name
           </em>
          </code>
          to create the bean.
         </p>
        </td>
       </tr>
      </tbody>
     </table>
    </div>
    <div class="paragraph">
     <p>
      Camel will bind
      <code>
       RouteTemplateContext
      </code>
      as the root object with name
      <code>
       rtc
      </code>
      when evaluating the script. This means you can get access to all the information from
      <code>
       RouteTemplateContext
      </code>
      and
      <code>
       CamelContext
      </code>
      via
      <code>
       rtc
      </code>
      .
     </p>
    </div>
    <div class="paragraph">
     <p>
      This is what we have done in the scripts in the previous examples where we get hold of a template parameter with:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">    rtc.getProperty('region', String.class)</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      To get access to
      <code>
       CamelContext
      </code>
      you can do:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-groovy hljs" data-lang="groovy">    var cn = rtc.getCamelContext().getName()</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      The most powerful languages to use are groovy and java. The other languages are limited in flexibility as they are not complete programming languages, but are more suited for templating needs.
     </p>
    </div>
    <div class="paragraph">
     <p>
      It is recommended to either use groovy or java, if creating the local bean requires coding, and the route templates are not defined using Java code.
     </p>
    </div>
    <div class="paragraph">
     <p>
      The bean language can be used when creating the local bean from an existing Java method (static or not-static method), and the route templates are not defined using Java code.
     </p>
    </div>
    <div class="paragraph">
     <p>
      For example suppose there is a class named
      <code>
       com.foo.MyAwsHelper
      </code>
      that has a method called
      <code>
       createS3Client
      </code>
      then you can call this method from the route template in XML DSL:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext&gt;
  &lt;routeTemplate id="s3template"&gt;
    &lt;templateParameter name="region"/&gt;
    &lt;templateParameter name="bucket"/&gt;
    &lt;templateBean name="myClient" type="bean"&gt;
        &lt;script&gt;com.foo.MyAwsHelper?method=createS3Client&lt;/script&gt;
    &lt;/templateBean&gt;
    &lt;route&gt;
      &lt;from uri="direct:s3-store"/&gt;
      &lt;to uri="aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}"/&gt;
    &lt;/route&gt;
  &lt;/routeTemplate&gt;
&lt;/camelContext&gt;</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      The method signature of createS3Client must then have one parameter for the
      <code>
       RouteTemplateContext
      </code>
      as shown:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public static S3Client createS3Client(RouteTemplateContext rtc) {
    return S3Client.builder()
        .region(rtc.getProperty("region", Region.class))
        .build();
}</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      If you are using pure Java code (both template and creating local bean), then you can create the local bean using Java lambda style as previously documented.
     </p>
    </div>
    <div class="sect3">
     <h4 id="_configuring_the_type_of_the_created_bean">
      <a class="anchor" href="#_configuring_the_type_of_the_created_bean">
      </a>
      Configuring the type of the created bean
     </h4>
     <div class="paragraph">
      <p>
       The
       <code>
        type
       </code>
       must be set to define what FQN class the created bean.
      </p>
     </div>
     <div class="listingblock">
      <div class="content">
       <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;camelContext&gt;
  &lt;routeTemplate id="s3template"&gt;
    &lt;templateParameter name="region"/&gt;
    &lt;templateParameter name="bucket"/&gt;
    &lt;templateBean name="myClient" scriptLanguage="bean" type="software.amazon.awssdk.services.s3.S3Client"&gt;
        &lt;script&gt;com.foo.MyAwsHelper?method=createS3Client&lt;/script&gt;
    &lt;/templateBean&gt;
    &lt;route&gt;
      &lt;from uri="direct:s3-store"/&gt;
      &lt;to uri="aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}"/&gt;
    &lt;/route&gt;
  &lt;/routeTemplate&gt;
&lt;/camelContext&gt;</code></pre>
      </div>
     </div>
     <div class="paragraph">
      <p>
       And in Java DSL you can do:
      </p>
     </div>
     <div class="listingblock">
      <div class="content">
       <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">routeTemplate("s3template")
    .templateParameter("region")
    .templateParameter("bucket")
    .templateBean("myClient", S3Client.class, "bean", "com.foo.MyAwsHelper?method=createS3Client")
    .from("direct:s3-store")
     // must refer to the bean with {{myClient}}
    .to("aws2-s3:{{bucket}}?amazonS3Client=#{{myClient}}")</code></pre>
      </div>
     </div>
    </div>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="_configuring_route_templates_when_creating_route">
   <a class="anchor" href="#_configuring_route_templates_when_creating_route">
   </a>
   Configuring route templates when creating route
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     There may be some special situations where you want to be able to do some custom configuration/code when a route is about to be created from a route template. To support this you can use the
     <code>
      configure
     </code>
     in the route template DSL where you can specify the code to execute as show:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">routeTemplate("myTemplate")
    .templateParameter("myTopic")
    .configure((RouteTemplateContext rtc) -&gt;
        // do some custom code here
    )
    .from("direct:to-topic")
    .to("kafka:{{myTopic}}");</code></pre>
    </div>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="_jmx_management">
   <a class="anchor" href="#_jmx_management">
   </a>
   JMX management
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     The route templates can be dumped as XML from the
     <code>
      ManagedCamelContextMBean
     </code>
     MBean via the
     <code>
      dumpRouteTemplatesAsXml
     </code>
     operation.
    </p>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="_creating_routes_from_a_properties_file">
   <a class="anchor" href="#_creating_routes_from_a_properties_file">
   </a>
   Creating routes from a properties file
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     When using
     <code>
      camel-main
     </code>
     you can specify the parameters for route templates in
     <code>
      application.properties
     </code>
     file.
    </p>
   </div>
   <div class="paragraph">
    <p>
     For example, given the route template below (from a
     <code>
      RouteBuilder
     </code>
     class):
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">routeTemplate("mytemplate")
    .templateParameter("input")
    .templateParameter("result")
    .from("direct:{{input}}")
        .to("mock:{{result}}");</code></pre>
    </div>
   </div>
   <div class="paragraph">
    <p>
     Then we can create two routes from this template by configuring the values in the
     <code>
      application.properties
     </code>
     file:
    </p>
   </div>
   <div class="listingblock">
    <div class="content">
     <pre class="highlightjs highlight"><code class="language-properties hljs" data-lang="properties">camel.route-template[0].template-id=mytemplate
camel.route-template[0].input=foo
camel.route-template[0].result=cheese

camel.route-template[1].template-id=mytemplate
camel.route-template[1].input=bar
camel.route-template[1].result=cheese</code></pre>
    </div>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="_creating_routes_from_custom_sources_of_template_parameters">
   <a class="anchor" href="#_creating_routes_from_custom_sources_of_template_parameters">
   </a>
   Creating routes from custom sources of template parameters
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     The SPI interface
     <code>
      org.apache.camel.spi.RouteTemplateParameterSource
     </code>
     can be used to implement custom sources that are used during startup of Camel to create routes via the templates with parameters from the custom source(s).
    </p>
   </div>
   <div class="paragraph">
    <p>
     For example, a custom source can be implemented to read parameters from a shared database that Camel uses during startup to create routes. This allows externalizing these parameters and as well to easily add more routes with varying parameters.
    </p>
   </div>
   <div class="paragraph">
    <p>
     To let Camel discover custom sources, then register the source into the Camel registry.
    </p>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="_see_also">
   <a class="anchor" href="#_see_also">
   </a>
   See Also
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     See the example
     <a href="https://github.com/apache/camel-examples/tree/main/routetemplate">
      camel-examples/examples/routetemplate/
     </a>
     .
    </p>
   </div>
  </div>
 </div>
</article>
