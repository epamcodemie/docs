<article class="doc">
 <h1 class="page">
  CamelContext
 </h1>
 <div id="preamble">
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     The
     <a href="https://www.javadoc.io/doc/org.apache.camel/camel-api/latest/org/apache/camel/CamelContext.html">
      <code>
       CamelContext
      </code>
     </a>
     is the runtime system, which holds together all the fundamental concepts of Apache Camel (routes, endpoints, components, etc).
    </p>
   </div>
   <div class="paragraph">
    <p>
     This context object represents the Camel runtime system. Typically, you have one
     <code>
      CamelContext
     </code>
     instance in an application.
    </p>
   </div>
   <div class="imageblock">
    <div class="content">
     <img alt="image" src="_images/images/camel-context.png"/>
    </div>
   </div>
   <div class="paragraph">
    <p>
     The
     <code>
      CamelContext
     </code>
     provides access to many features and services, the most notable being components, type converters, a registry, endpoints, routes, data formats, and languages.
    </p>
   </div>
   <div class="paragraph">
    <p>
     The following table lists the most common services provided by the
     <code>
      CamelContext
     </code>
     :
    </p>
   </div>
   <div class="table-wrapper">
    <table class="tableblock frame-all grid-all stretch">
     <colgroup>
      <col/>
      <col/>
     </colgroup>
     <thead>
      <tr>
       <th class="tableblock halign-left valign-top">
        Service
       </th>
       <th class="tableblock halign-left valign-top">
        Description
       </th>
      </tr>
     </thead>
     <tbody>
      <tr>
       <td class="tableblock halign-left valign-top">
        <p class="tableblock">
         <a class="xref page" href="component.html">
          Components
         </a>
        </p>
       </td>
       <td class="tableblock halign-left valign-top">
        <p class="tableblock">
         Contains the components used.
        </p>
       </td>
      </tr>
      <tr>
       <td class="tableblock halign-left valign-top">
        <p class="tableblock">
         <a class="xref page" href="endpoint.html">
          Endpoints
         </a>
        </p>
       </td>
       <td class="tableblock halign-left valign-top">
        <p class="tableblock">
         Contains the endpoints that have been used.
        </p>
       </td>
      </tr>
      <tr>
       <td class="tableblock halign-left valign-top">
        <p class="tableblock">
         <a class="xref page" href="routes.html">
          Routes
         </a>
        </p>
       </td>
       <td class="tableblock halign-left valign-top">
        <p class="tableblock">
         The routes in use.
        </p>
       </td>
      </tr>
      <tr>
       <td class="tableblock halign-left valign-top">
        <p class="tableblock">
         <a class="xref page" href="data-format.html">
          Data formats
         </a>
        </p>
       </td>
       <td class="tableblock halign-left valign-top">
        <p class="tableblock">
         Contains the loaded data formats.
        </p>
       </td>
      </tr>
      <tr>
       <td class="tableblock halign-left valign-top">
        <p class="tableblock">
         <a class="xref page" href="languages.html">
          Languages
         </a>
        </p>
       </td>
       <td class="tableblock halign-left valign-top">
        <p class="tableblock">
         Contains the loaded languages.
        </p>
       </td>
      </tr>
      <tr>
       <td class="tableblock halign-left valign-top">
        <p class="tableblock">
         <a class="xref page" href="type-converter.html">
          Type converters
         </a>
        </p>
       </td>
       <td class="tableblock halign-left valign-top">
        <p class="tableblock">
         Contains the loaded type converters. Camel has a mechanism that allows you to manually or automatically convert from one type to another.
        </p>
       </td>
      </tr>
      <tr>
       <td class="tableblock halign-left valign-top">
        <p class="tableblock">
         <a class="xref page" href="registry.html">
          Registry
         </a>
        </p>
       </td>
       <td class="tableblock halign-left valign-top">
        <p class="tableblock">
         Contains a registry that allows you to look up beans.
        </p>
       </td>
      </tr>
     </tbody>
    </table>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="_camelcontext_101">
   <a class="anchor" href="#_camelcontext_101">
   </a>
   CamelContext 101
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     To give you a better understanding of Apache Camel, we’ll discuss what is inside the
     <code>
      CamelContext
     </code>
     .
    </p>
   </div>
   <div class="sect2">
    <h3 id="_routing_engine">
     <a class="anchor" href="#_routing_engine">
     </a>
     Routing Engine
    </h3>
    <div class="paragraph">
     <p>
      Camel’s routing engine moves messages under the hood and does all the heavy lifting to ensure that messages are routed properly. It is not exposed to the developer, but you should be aware that it’s there.
     </p>
    </div>
   </div>
   <div class="sect2">
    <h3 id="_routes">
     <a class="anchor" href="#_routes">
     </a>
     Routes
    </h3>
    <div class="paragraph">
     <p>
      <a class="xref page" href="routes.html">
       Routes
      </a>
      are a core abstraction for Camel. The simplest way to define a route is as a chain of
      <a class="xref page" href="processor.html">
       Processors
      </a>
      . There are many reasons for using routers in messaging applications. By decoupling clients from servers, and producers from consumers, routes can, for example, do the following:
     </p>
    </div>
    <div class="ulist">
     <ul>
      <li>
       <p>
        Decide dynamically what server a client will invoke
       </p>
      </li>
      <li>
       <p>
        Provide a flexible way to add extra processing
       </p>
      </li>
      <li>
       <p>
        Allow independent development for clients and servers
       </p>
      </li>
      <li>
       <p>
        Foster better design practices by connecting disparate systems that do one thing well
       </p>
      </li>
      <li>
       <p>
        Allow for clients of servers to be stubbed out (using
        <a class="xref page" href="../components/4.10.x/mock-component.html">
         mocks
        </a>
        ) for testing purposes
       </p>
      </li>
     </ul>
    </div>
    <div class="paragraph">
     <p>
      Each route in Camel has a unique identifier. You can use the identifier to log, debug, monitor, and start and stop routes.
     </p>
    </div>
    <div class="paragraph">
     <p>
      Routes have one and only one input source for messages. They are effectively tied to an input endpoint.
     </p>
    </div>
   </div>
   <div class="sect2">
    <h3 id="_domain_specific_language_dsl">
     <a class="anchor" href="#_domain_specific_language_dsl">
     </a>
     Domain Specific Language (DSL)
    </h3>
    <div class="paragraph">
     <p>
      To wire processors and endpoints together to form routes, Camel defines a
      <a class="xref page" href="dsl.html">
       DSL
      </a>
      .
     </p>
    </div>
    <div class="paragraph">
     <p>
      In Camel with Java, DSL means a fluent Java API that contains methods named for EIP terms.
     </p>
    </div>
    <div class="paragraph">
     <p>
      Consider this example:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">from("file:data/inbox")
    .filter().xpath("/order[not(@test)]")
        .to("jms:queue:order");</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      Here, in a single Java statement, you define a route that consumes files from a
      <a class="xref page" href="../components/4.10.x/file-component.html">
       file
      </a>
      endpoint. Camel uses the
      <a class="xref page" href="../components/4.10.x/eips/filter-eip.html">
       Filter EIP
      </a>
      to route the messages using an XPath predicate to test whether the message is not a test order. If a message passes the test, Camel forwards it to the
      <a class="xref page" href="../components/4.10.x/jms-component.html">
       JMS
      </a>
      endpoint. Messages failing the filter test are skipped.
     </p>
    </div>
    <div class="paragraph">
     <p>
      Camel provides multiple DSL languages. You could define the same route using the XML DSL:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;route&gt;
    &lt;from uri="file:data/inbox"/&gt;
    &lt;filter&gt;
        &lt;xpath&gt;/order[not(@test)]&lt;/xpath&gt;
        &lt;to uri="jms:queue:order"/&gt;
    &lt;/filter&gt;
&lt;/route&gt;</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      And in YAML:
     </p>
    </div>
    <div class="listingblock">
     <div class="content">
      <pre class="highlightjs highlight"><code class="language-yaml hljs" data-lang="yaml">- from:
    uri: "file:data/inbox"
    steps:
      - filter:
          xpath: "/order[not(@test)]"
          steps:
            - to: "jms:queue:order"</code></pre>
     </div>
    </div>
    <div class="paragraph">
     <p>
      The DSLs provide a nice abstraction for Camel users to build applications. Under the hood, though, a route is composed of a graph of processors.
     </p>
    </div>
   </div>
   <div class="sect2">
    <h3 id="_processors">
     <a class="anchor" href="#_processors">
     </a>
     Processors
    </h3>
    <div class="paragraph">
     <p>
      The
      <a class="xref page" href="processor.html">
       processor
      </a>
      is a core Camel concept that represents a node capable of using, creating, or modifying an incoming
      <a class="xref page" href="exchange.html">
       exchange
      </a>
      .
     </p>
    </div>
    <div class="paragraph">
     <p>
      During routing, exchanges flow from one processor to another; as such, you can think of a route as a graph having specialized processors as the nodes, and lines that connect the output of one processor to the input of another. Processors could be implementations of EIPs, producers for specific components, or your own custom code. The figure below shows the flow between processors.
     </p>
    </div>
    <div class="imageblock">
     <div class="content">
      <img alt="image" src="_images/images/message_flow_in_route.png"/>
     </div>
    </div>
    <div class="paragraph">
     <p>
      A route starts with a consumer (i.e.,
      <code>
       from
      </code>
      in the DSL) that populates the initial
      <a class="xref page" href="exchange.html">
       exchange
      </a>
      . At each processor step, the output (out) message from the previous step is the input (in) message of the next. In many cases, processors don’t set an out message, so in this case the in message is reused. The
      <a class="xref page" href="exchange-pattern.html">
       exchange pattern
      </a>
      of the exchange determines, at the end of a route, whether a reply needs to be sent back to the caller of the route. If the exchange pattern (MEP) is
      <code>
       InOnly
      </code>
      , no reply will be sent back. If it’s
      <code>
       InOut
      </code>
      , Camel will take the out message from the last step and return it.
     </p>
    </div>
   </div>
   <div class="sect2">
    <h3 id="_component">
     <a class="anchor" href="#_component">
     </a>
     Component
    </h3>
    <div class="paragraph">
     <p>
      <a class="xref page" href="../components/4.10.x/index.html">
       Components
      </a>
      are the main extension point in Camel.
     </p>
    </div>
    <div class="paragraph">
     <p>
      From a programming point of view, components are fairly simple: they’re associated with a name that’s used in a
      <a class="xref page" href="uris.html">
       URI
      </a>
      , and they act as a factory of
      <a class="xref page" href="endpoint.html">
       endpoints
      </a>
      .
     </p>
    </div>
    <div class="paragraph">
     <p>
      For example,
      <code>
       FileComponent
      </code>
      is referred to by file in a URI, and it creates
      <code>
       FileEndpoint
      </code>
      . The endpoint is perhaps an even more fundamental concept in Camel.
     </p>
    </div>
   </div>
   <div class="sect2">
    <h3 id="_endpoint">
     <a class="anchor" href="#_endpoint">
     </a>
     Endpoint
    </h3>
    <div class="paragraph">
     <p>
      An
      <a class="xref page" href="endpoint.html">
       endpoint
      </a>
      is the Camel abstraction that models the end of a channel through which a system can send or receive messages.
     </p>
    </div>
    <div class="imageblock">
     <div class="content">
      <img alt="image" src="_images/images/MessageEndpointSolution.gif"/>
     </div>
    </div>
    <div class="paragraph">
     <p>
      In Camel, you configure endpoints by using URIs, such as
      <code>
       file:data/inbox?delay=5000
      </code>
      , and you also refer to endpoints this way. At runtime, Camel looks up an endpoint based on the URI notation. The figure below shows how this works.
     </p>
    </div>
    <div class="imageblock">
     <div class="content">
      <img alt="image" src="_images/images/endpoint-uri-syntax.png"/>
     </div>
    </div>
    <div class="paragraph">
     <p>
      The scheme (1) denotes which Camel component handles that type of endpoint. In this case, the scheme of
      <code>
       file
      </code>
      selects
      <code>
       FileComponent
      </code>
      .
      <code>
       FileComponent
      </code>
      then works as a factory, creating
      <code>
       FileEndpoint
      </code>
      based on the remaining parts of the URI. The context path
      <code>
       data/inbox
      </code>
      (2) tells
      <code>
       FileComponent
      </code>
      that the starting folder is
      <code>
       data/inbox
      </code>
      . The option,
      <code>
       delay=5000
      </code>
      (3) indicates that files should be polled at a 5-second interval.
     </p>
    </div>
    <div class="paragraph">
     <p>
      The next figure shows how an endpoint works together with an exchange, producers, and consumers.
     </p>
    </div>
    <div class="imageblock">
     <div class="content">
      <img alt="image" src="_images/images/endpoint-factory.png"/>
     </div>
    </div>
    <div class="paragraph">
     <p>
      An endpoint acts as a factory for creating consumers and producers that are capable of receiving and sending messages to a particular endpoint.
     </p>
    </div>
   </div>
   <div class="sect2">
    <h3 id="_producer">
     <a class="anchor" href="#_producer">
     </a>
     Producer
    </h3>
    <div class="paragraph">
     <p>
      A producer is the Camel abstraction that refers to an entity capable of sending a message to an endpoint. When a message is sent to an endpoint, the producer handles the details of getting the message data compatible with that particular endpoint. For example,
      <code>
       FileProducer
      </code>
      will write the message body to a
      <code>
       java.io.File
      </code>
      .
      <code>
       JmsProducer
      </code>
      , on the other hand, will map the Camel message to
      <code>
       javax.jms.Message
      </code>
      before sending it to a JMS destination. This is an important feature in Camel, because it hides the complexity of interacting with particular transports. All you need to do is route a message to an endpoint, and the producer does the heavy lifting.
     </p>
    </div>
   </div>
   <div class="sect2">
    <h3 id="_consumer">
     <a class="anchor" href="#_consumer">
     </a>
     Consumer
    </h3>
    <div class="paragraph">
     <p>
      A consumer is the service that receives messages produced by some external system, wraps them in an
      <a class="xref page" href="exchange.html">
       exchange
      </a>
      , and sends them to be processed. Consumers are the source of the exchanges being routed in Apache Camel. To create a new exchange, a consumer will use the endpoint that wraps the payload being consumed. A
      <a class="xref page" href="processor.html">
       processor
      </a>
      is then used to initiate the routing of the exchange in Camel via the routing engine.
     </p>
    </div>
    <div class="paragraph">
     <p>
      Camel has two kinds of consumers: event-driven consumers, and polling consumers (or scheduled polling consumers). The differences between these consumers are important, because they help solve different problems.
     </p>
    </div>
    <div class="sect3">
     <h4 id="_event_driven_consumer">
      <a class="anchor" href="#_event_driven_consumer">
      </a>
      Event Driven Consumer
     </h4>
     <div class="paragraph">
      <p>
       The most familiar consumer is the event-driven consumer, as illustrated:
      </p>
     </div>
     <div class="imageblock">
      <div class="content">
       <img alt="image" src="_images/images/EventDrivenConsumerSolution.gif"/>
      </div>
     </div>
     <div class="paragraph">
      <p>
       This kind of consumer is mostly associated with client-server architectures and web services. It’s also referred to as an asynchronous receiver in the EIP world. An event-driven consumer listens on a particular messaging channel, such as a TCP/IP port, JMS queue, Twitter handle, Amazon SQS queue, WebSocket, and so on. It then waits for a client to send messages to it. When a message arrives, the consumer wakes up and takes the message for processing.
      </p>
     </div>
    </div>
    <div class="sect3">
     <h4 id="_polling_consumer_scheduled_polling_consumer">
      <a class="anchor" href="#_polling_consumer_scheduled_polling_consumer">
      </a>
      Polling Consumer / Scheduled Polling Consumer
     </h4>
     <div class="paragraph">
      <p>
       In contrast to the event-driven consumer, the polling consumer actively goes and fetches messages from a particular source, such as an FTP server. The polling consumer is also known as a synchronous receiver in EIP lingo, because it won’t poll for more messages until it’s finished processing the current message. A common flavor of the polling consumer is the scheduled polling consumer, which polls at scheduled intervals. File, FTP, and email components all use scheduled polling consumers.
      </p>
     </div>
     <div class="admonitionblock note">
      <div class="table-wrapper">
       <table>
        <tr>
         <td class="icon">
          <i class="fa icon-note" title="Note">
          </i>
         </td>
         <td class="content">
          In the Camel components, its only either the event driven or scheduled polling consumers that are in use. The polling consumer (non-scheduled) is only used to poll on-demand, such as when using the
          <a class="xref page" href="../components/4.10.x/eips/pollEnrich-eip.html">
           Poll Enrich
          </a>
          EIP, or from Java by creating a
          <code>
           PollingConsumer
          </code>
          instance via the
          <code>
           createPollingConsumer()
          </code>
          method from
          <code>
           Endpoint
          </code>
          .
         </td>
        </tr>
       </table>
      </div>
     </div>
    </div>
   </div>
  </div>
 </div>
 <div class="sect1">
  <h2 id="_see_also">
   <a class="anchor" href="#_see_also">
   </a>
   See Also
  </h2>
  <div class="sectionbody">
   <div class="paragraph">
    <p>
     See the following for high-level
     <a class="xref page" href="architecture.html">
      architecture
     </a>
     of Apache Camel.
    </p>
   </div>
   <div class="paragraph">
    <p>
     See
     <a class="xref page" href="lifecycle.html">
      Lifecycle
     </a>
     to understand the overall lifecycle of the
     <code>
      CamelContext
     </code>
     .
    </p>
   </div>
  </div>
 </div>
</article>
